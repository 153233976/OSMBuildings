var Shaders = {"interaction":{"vertex":"#ifdef GL_ES\n  precision mediump float;\n#endif\nattribute vec4 aPosition;\nattribute vec3 aColor;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjMatrix;\nuniform mat4 uMatrix;\nuniform float uFogRadius;\nvarying vec4 vColor;\nvoid main() {\n  gl_Position = uMatrix * aPosition;\n  vec4 mPosition = vec4(uModelMatrix * aPosition);\n  float distance = length(mPosition);\n  if (distance > uFogRadius) {\n    vColor = vec4(0.0, 0.0, 0.0, 0.0);\n  } else {\n    vColor = vec4(aColor, 1.0);\n  }\n}\n","fragment":"#ifdef GL_ES\n  precision mediump float;\n#endif\nvarying vec4 vColor;\nvoid main() {\n  gl_FragColor = vColor;\n}\n"},"buildings":{"vertex":"#ifdef GL_ES\n  precision mediump float;\n#endif\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nattribute vec3 aNormal;\nattribute vec3 aColor;\nattribute vec3 aIDColor;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjMatrix;\nuniform mat4 uMatrix;\nuniform mat3 uNormalTransform;\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec3 uFogColor;\nuniform float uFogRadius;\nuniform vec3 uHighlightColor;\nuniform vec3 uHighlightID;\nvarying vec3 vColor;\nfloat fogBlur = 200.0;\nfloat gradientHeight = 90.0;\nfloat gradientStrength = 0.4;\n// helsinki has small buildings :-)\n//float gradientHeight = 30.0;\n//float gradientStrength = 0.3;\n//uniform float uRadius;\n//uniform float uDistance;\nfloat uRadius = 500.0;\nfloat uDistance = 700.0;\nvoid main() {\n  //*** bending ***************************************************************\n  vec4 mwPosition = uViewMatrix * uModelMatrix * aPosition;\n  float innerRadius = uRadius + mwPosition.y;\n  float depth = abs(mwPosition.z);\n  float s = depth-uDistance;\n  float theta = min(max(s, 0.0)/uRadius, halfPi);\n  // halfPi*uRadius, not halfPi*innerRadius, because the \"base\" of a building\n  // travels the full uRadius path\n  float newY = cos(theta)*innerRadius -uRadius - max(s-halfPi*uRadius, 0.0);\n  float newZ = normalize(mwPosition.z) * (min(depth, uDistance) + sin(theta)*innerRadius);\n  vec4 newPosition = vec4(mwPosition.x, newY, newZ, 1.0);\n  gl_Position = uProjMatrix * newPosition;\n//  gl_Position = uMatrix * aPosition;\n  //*** highlight object ******************************************************\n  vec3 color = aColor;\n  if (uHighlightID.r == aIDColor.r && uHighlightID.g == aIDColor.g && uHighlightID.b == aIDColor.b) {\n    color = mix(aColor, uHighlightColor, 0.5);\n  }\n  //*** light intensity, defined by light direction on surface ****************\n  vec3 transformedNormal = aNormal * uNormalTransform;\n  float lightIntensity = max( dot(transformedNormal, uLightDirection), 0.0) / 1.5;\n  color = color + uLightColor * lightIntensity;\n  //*** vertical shading ******************************************************\n  float verticalShading = clamp((gradientHeight-aPosition.z) / (gradientHeight/gradientStrength), 0.0, gradientStrength);\n  //*** fog *******************************************************************\n  vec4 mPosition = uModelMatrix * aPosition;\n  float distance = length(mPosition);\n  float fogIntensity = (distance - uFogRadius) / fogBlur + 1.1; // <- shifts blur in/out\n  fogIntensity = clamp(fogIntensity, 0.0, 1.0);\n  //***************************************************************************\n  vColor = mix(vec3(color - verticalShading), uFogColor, fogIntensity);\n}\n","fragment":"#ifdef GL_ES\n  precision mediump float;\n#endif\nvarying vec3 vColor;\nvoid main() {\n  gl_FragColor = vec4(vColor, 1.0);\n}\n"},"skydome":{"vertex":"#ifdef GL_ES\n  precision mediump float;\n#endif\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjMatrix;\nuniform mat4 uMatrix;\nvarying vec2 vTexCoord;\nvarying float vFogIntensity;\nfloat gradientHeight = 10.0;\nfloat gradientStrength = 1.0;\n//uniform float uRadius;\n//uniform float uDistance;\nfloat uRadius = 500.0;\nfloat uDistance = 700.0;\nvoid main() {\n  //*** bending ***************************************************************\n  vec4 mwPosition = uViewMatrix * uModelMatrix * aPosition;\n  float innerRadius = uRadius + mwPosition.y;\n  float depth = abs(mwPosition.z);\n  float s = depth-uDistance;\n  float theta = min(max(s, 0.0)/uRadius, halfPi);\n  // halfPi*uRadius, not halfPi*innerRadius, because the \"base\" of a building\n  // travels the full uRadius path\n  float newY = cos(theta)*innerRadius -uRadius - max(s-halfPi*uRadius, 0.0);\n  float newZ = normalize(mwPosition.z) * (min(depth, uDistance) + sin(theta)*innerRadius);\n  vec4 newPosition = vec4(mwPosition.x, newY, newZ, 1.0);\n  gl_Position = uProjMatrix * newPosition;\n//  gl_Position = uMatrix * aPosition;\n  vTexCoord = aTexCoord;\n  vFogIntensity = clamp((gradientHeight-aPosition.z) / (gradientHeight/gradientStrength), 0.0, gradientStrength);\n}\n","fragment":"#ifdef GL_ES\n  precision mediump float;\n#endif\nuniform sampler2D uTexIndex;\nuniform vec3 uFogColor;\nvarying vec2 vTexCoord;\nvarying float vFogIntensity;\nvoid main() {\n  vec3 color = vec3(texture2D(uTexIndex, vec2(vTexCoord.x, -vTexCoord.y)));\n  gl_FragColor = vec4(mix(color, uFogColor, vFogIntensity), 1.0);\n}\n"},"basemap":{"vertex":"#ifdef GL_ES\n  precision mediump float;\n#endif\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjMatrix;\nuniform mat4 uMatrix;\nuniform float uFogRadius;\nvarying vec2 vTexCoord;\nvarying float vFogIntensity;\nfloat fogBlur = 200.0;\n//uniform float uRadius;\n//uniform float uDistance;\nfloat uRadius = 500.0;\nfloat uDistance = 700.0;\nvoid main() {\n  //*** bending ***************************************************************\n  vec4 mwPosition = uViewMatrix * uModelMatrix * aPosition;\n  float innerRadius = uRadius + mwPosition.y;\n  float depth = abs(mwPosition.z);\n  float s = depth-uDistance;\n  float theta = min(max(s, 0.0)/uRadius, halfPi);\n  // halfPi*uRadius, not halfPi*innerRadius, because the \"base\" of a building\n  // travels the full uRadius path\n  float newY = cos(theta)*innerRadius -uRadius - max(s-halfPi*uRadius, 0.0);\n  float newZ = normalize(mwPosition.z) * (min(depth, uDistance) + sin(theta)*innerRadius);\n  vec4 newPosition = vec4(mwPosition.x, newY, newZ, 1.0);\n  vec4 glPosition = uProjMatrix * newPosition;\n//  vec4 glPosition = uMatrix * aPosition;\n  gl_Position = glPosition;\n  vTexCoord = aTexCoord;\n  //*** fog *******************************************************************\n  vec4 mPosition = uModelMatrix * aPosition;\n  float distance = length(mPosition);\n  // => (distance - (uFogRadius - fogBlur)) / (uFogRadius - (uFogRadius - fogBlur));\n  float fogIntensity = (distance - uFogRadius) / fogBlur + 1.1; // <- shifts blur in/out\n  vFogIntensity = clamp(fogIntensity, 0.0, 1.0);\n  //vFogIntensity = 0.0;\n}\n","fragment":"#ifdef GL_ES\n  precision mediump float;\n#endif\nuniform sampler2D uTexIndex;\nuniform vec3 uFogColor;\nvarying vec2 vTexCoord;\nvarying float vFogIntensity;\nvoid main() {\n  vec3 color = vec3(texture2D(uTexIndex, vec2(vTexCoord.x, -vTexCoord.y)));\n  gl_FragColor = vec4(mix(color, uFogColor, vFogIntensity), 1.0);\n}\n"}};
