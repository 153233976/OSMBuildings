!function(){var e=function(){var e={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgrey:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",grey:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"};function t(e,t,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?e+6*(t-e)*i:i<.5?t:i<2/3?e+(t-e)*(2/3-i)*6:e}function i(e,t){if(void 0!==e)return Math.min(t,Math.max(0,e||0))}var r=function(e,t,r,o){this.r=i(e,1),this.g=i(t,1),this.b=i(r,1),this.a=i(o,1)||1};return r.parse=function(t){if("string"==typeof t){var i;if(t=t.toLowerCase(),i=(t=e[t]||t).match(/^#?(\w{2})(\w{2})(\w{2})$/))return new r(parseInt(i[1],16)/255,parseInt(i[2],16)/255,parseInt(i[3],16)/255);if(i=t.match(/^#?(\w)(\w)(\w)$/))return new r(parseInt(i[1]+i[1],16)/255,parseInt(i[2]+i[2],16)/255,parseInt(i[3]+i[3],16)/255);if(i=t.match(/rgba?\((\d+)\D+(\d+)\D+(\d+)(\D+([\d.]+))?\)/))return new r(parseFloat(i[1])/255,parseFloat(i[2])/255,parseFloat(i[3])/255,i[4]?parseFloat(i[5]):1)}return new r},r.fromHSL=function(e,t,i){var o=(new r).fromHSL(e,t,i);return o.a=a,o},r.prototype={isValid:function(){return void 0!==this.r&&void 0!==this.g&&void 0!==this.b},toHSL:function(){if(this.isValid()){var e,t,i=Math.max(this.r,this.g,this.b),r=Math.min(this.r,this.g,this.b),o=(i+r)/2,n=i-r;if(n){switch(t=o>.5?n/(2-i-r):n/(i+r),i){case this.r:e=(this.g-this.b)/n+(this.g<this.b?6:0);break;case this.g:e=(this.b-this.r)/n+2;break;case this.b:e=(this.r-this.g)/n+4}e*=60}else e=t=0;return{h:e,s:t,l:o}}},fromHSL:function(e,i,r){if(0===i)return this.r=this.g=this.b=r,this;var o=r<.5?r*(1+i):r+i-r*i,n=2*r-o;return e/=360,this.r=t(n,o,e+1/3),this.g=t(n,o,e),this.b=t(n,o,e-1/3),this},toString:function(){if(this.isValid())return 1===this.a?"#"+((1<<24)+(Math.round(255*this.r)<<16)+(Math.round(255*this.g)<<8)+Math.round(255*this.b)).toString(16).slice(1,7):"rgba("+[Math.round(255*this.r),Math.round(255*this.g),Math.round(255*this.b),this.a.toFixed(2)].join(",")+")"},toArray:function(){if(this.isValid)return[this.r,this.g,this.b]},hue:function(e){var t=this.toHSL();return this.fromHSL(t.h+e,t.s,t.l)},saturation:function(e){var t=this.toHSL();return this.fromHSL(t.h,t.s*e,t.l)},lightness:function(e){var t=this.toHSL();return this.fromHSL(t.h,t.s,t.l*e)},clone:function(){return new r(this.r,this.g,this.b,this.a)}},r}();"object"==typeof module&&(module.exports=e);var t=function(){"use strict";var e=Math.PI,t=Math.sin,i=Math.cos,r=Math.tan,o=Math.asin,n=Math.atan2,a=e/180,s=864e5,u=2440588,h=2451545;function l(e){return function(e){return e.valueOf()/s-.5+u}(e)-h}var d=23.4397*a;function f(s){var u,h,l=function(i){return i+a*(1.9148*t(i)+.02*t(2*i)+3e-4*t(3*i))+102.9372*a+e}(function(e){return a*(357.5291+.98560028*e)}(s));return{dec:(u=l,h=0,o(t(h)*i(d)+i(h)*t(d)*t(u))),ra:function(e,o){return n(t(e)*i(d)-r(o)*t(d),i(e))}(l,0)}}return function(e,s,u){var h=a*-u,d=a*s,c=l(e),m=f(c),g=function(e,t){return a*(280.16+360.9856235*e)-t}(c,h)-m.ra;return{azimuth:function(e,o,a){return n(t(e),i(e)*t(o)-r(a)*i(o))}(g,d,m.dec),altitude:function(e,r,n){return o(t(r)*t(n)+i(r)*i(n)*i(e))}(g,d,m.dec)}}}();const i={picking:{vertex:"precision highp float; //is default in vertex shaders anyway, using highp fixes #49\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nattribute vec3 aPickingColor;\nattribute float aZScale;\nuniform mat4 uModelMatrix;\nuniform mat4 uMatrix;\nuniform float uFogDistance;\nuniform float uFade;\nuniform float uIndex;\nvarying vec4 vColor;\nvoid main() {\nfloat f = clamp(uFade*aZScale, 0.0, 1.0);\nif (f == 0.0) {\ngl_Position = vec4(0.0, 0.0, 0.0, 0.0);\nvColor = vec4(0.0, 0.0, 0.0, 0.0);\n} else {\nvec4 pos = vec4(aPosition.x, aPosition.y, aPosition.z*f, aPosition.w);\ngl_Position = uMatrix * pos;\nvec4 mPosition = vec4(uModelMatrix * pos);\nfloat distance = length(mPosition);\nif (distance > uFogDistance) {\nvColor = vec4(0.0, 0.0, 0.0, 0.0);\n} else {\nvColor = vec4(clamp(uIndex, 0.0, 1.0), aPickingColor.g, aPickingColor.b, 1.0);\n}\n}\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec4 vColor;\nvoid main() {\ngl_FragColor = vColor;\n}\n"},buildings:{vertex:"precision highp float; //is default in vertex shaders anyway, using highp fixes #49\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nattribute vec3 aNormal;\nattribute vec3 aColor;\nattribute float aHeight;\nattribute vec4 aTintColor;\nattribute float aZScale;\nuniform mat4 uModelMatrix;\nuniform mat4 uMatrix;\nuniform mat3 uNormalTransform;\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec2 uViewDirOnMap;\nuniform vec2 uLowerEdgePoint;\nuniform float uFade;\nvarying vec3 vColor;\nvarying vec2 vTexCoord;\nvarying float verticalDistanceToLowerEdge;\nconst float gradientStrength = 0.4;\nvoid main() {\nfloat f = clamp(uFade*aZScale, 0.0, 1.0);\nif (f == 0.0) {\ngl_Position = vec4(0.0, 0.0, 0.0, 0.0);\nvColor = vec3(0.0, 0.0, 0.0);\n} else {\nvec4 pos = vec4(aPosition.x, aPosition.y, aPosition.z*f, aPosition.w);\ngl_Position = uMatrix * pos;\nvec3 color = aColor;\n// tint ***********************************************\nif (aTintColor.a > 0.0) {\ncolor = mix(aColor, aTintColor.rgb, 0.5);\n}\n//*** light intensity, defined by light direction on surface ****************\nvec3 transformedNormal = aNormal * uNormalTransform;\nfloat lightIntensity = max( dot(transformedNormal, uLightDirection), 0.0) / 1.5;\ncolor = color + uLightColor * lightIntensity;\nvTexCoord = aTexCoord;\n//*** vertical shading ******************************************************\nfloat verticalShading = clamp(gradientStrength - ((pos.z*gradientStrength) / (aHeight * f)), 0.0, gradientStrength);\n//***************************************************************************\nvColor = color-verticalShading;\nvec4 worldPos = uModelMatrix * pos;\nvec2 dirFromLowerEdge = worldPos.xy / worldPos.w - uLowerEdgePoint;\nverticalDistanceToLowerEdge = dot(dirFromLowerEdge, uViewDirOnMap);\n}\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec3 vColor;\nvarying vec2 vTexCoord;\nvarying float verticalDistanceToLowerEdge;\nuniform vec3 uFogColor;\nuniform float uFogDistance;\nuniform float uFogBlurDistance;\nuniform sampler2D uWallTexIndex;\nvoid main() {\n\nfloat fogIntensity = (verticalDistanceToLowerEdge - uFogDistance) / uFogBlurDistance;\nfogIntensity = clamp(fogIntensity, 0.0, 1.0);\ngl_FragColor = vec4( vColor* texture2D(uWallTexIndex, vTexCoord).rgb, 1.0-fogIntensity);\n}\n"},buildings_with_shadows:{vertex:"precision highp float; //is default in vertex shaders anyway, using highp fixes #49\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nattribute vec3 aNormal;\nattribute vec3 aColor;\nattribute vec2 aTexCoord;\nattribute float aHeight;\nattribute vec4 aTintColor;\nattribute float aZScale;\nuniform mat4 uModelMatrix;\nuniform mat4 uMatrix;\nuniform mat4 uSunMatrix;\nuniform mat3 uNormalTransform;\nuniform vec2 uViewDirOnMap;\nuniform vec2 uLowerEdgePoint;\nuniform float uFade;\nvarying vec3 vColor;\nvarying vec2 vTexCoord;\nvarying vec3 vNormal;\nvarying vec3 vSunRelPosition;\nvarying float verticalDistanceToLowerEdge;\nfloat gradientStrength = 0.4;\nvoid main() {\nfloat f = clamp(uFade*aZScale, 0.0, 1.0);\nif (f == 0.0) {\ngl_Position = vec4(0.0, 0.0, 0.0, 0.0);\nvColor = vec3(0.0, 0.0, 0.0);\n} else {\nvec4 pos = vec4(aPosition.x, aPosition.y, aPosition.z*f, aPosition.w);\ngl_Position = uMatrix * pos;\nvec3 color = aColor;\n// tint ***********************************************\nif (aTintColor.a > 0.0) {\ncolor = mix(aColor, aTintColor.rgb, 0.5);\n}\n//*** light intensity, defined by light direction on surface ****************\nvNormal = aNormal;\nvTexCoord = aTexCoord;\n//vec3 transformedNormal = aNormal * uNormalTransform;\n//float lightIntensity = max( dot(aNormal, uLightDirection), 0.0) / 1.5;\n//color = color + uLightColor * lightIntensity;\n//*** vertical shading ******************************************************\nfloat verticalShading = clamp(gradientStrength - ((pos.z*gradientStrength) / (aHeight * f)), 0.0, gradientStrength);\n//***************************************************************************\nvColor = color-verticalShading;\nvec4 worldPos = uModelMatrix * pos;\nvec2 dirFromLowerEdge = worldPos.xy / worldPos.w - uLowerEdgePoint;\nverticalDistanceToLowerEdge = dot(dirFromLowerEdge, uViewDirOnMap);\n// *** shadow mapping ********\nvec4 sunRelPosition = uSunMatrix * pos;\nvSunRelPosition = (sunRelPosition.xyz / sunRelPosition.w + 1.0) / 2.0;\n}\n}\n",fragment:"\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nvarying vec2 vTexCoord;\nvarying vec3 vColor;\nvarying vec3 vNormal;\nvarying vec3 vSunRelPosition;\nvarying float verticalDistanceToLowerEdge;\nuniform vec3 uFogColor;\nuniform vec2 uShadowTexDimensions;\nuniform sampler2D uShadowTexIndex;\nuniform sampler2D uWallTexIndex;\nuniform float uFogDistance;\nuniform float uFogBlurDistance;\nuniform float uShadowStrength;\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nfloat isSeenBySun(const vec2 sunViewNDC, const float depth, const float bias) {\nif ( clamp( sunViewNDC, 0.0, 1.0) != sunViewNDC) //not inside sun's viewport\nreturn 1.0;\n\nfloat depthFromTexture = texture2D( uShadowTexIndex, sunViewNDC.xy).x;\n\n//compare depth values not in reciprocal but in linear depth\nreturn step(1.0/depthFromTexture, 1.0/depth + bias);\n}\nvoid main() {\nvec3 normal = normalize(vNormal); //may degenerate during per-pixel interpolation\nfloat diffuse = dot(uLightDirection, normal);\ndiffuse = max(diffuse, 0.0);\n// reduce shadow strength with:\n// - lowering sun positions, to be consistent with the shadows on the basemap (there,\n// shadows are faded out with lowering sun positions to hide shadow artifacts caused\n// when sun direction and map surface are almost perpendicular\n// - large angles between the sun direction and the surface normal, to hide shadow\n// artifacts that occur when surface normal and sun direction are almost perpendicular\nfloat shadowStrength = pow( max( min(\ndot(uLightDirection, vec3(0.0, 0.0, 1.0)),\ndot(uLightDirection, normal)\n), 0.0), 1.5);\nif (diffuse > 0.0 && shadowStrength > 0.0) {\n// note: the diffuse term is also the cosine between the surface normal and the\n// light direction\nfloat bias = clamp(0.0007*tan(acos(diffuse)), 0.0, 0.01);\nvec2 pos = fract( vSunRelPosition.xy * uShadowTexDimensions);\n\nvec2 tl = floor(vSunRelPosition.xy * uShadowTexDimensions) / uShadowTexDimensions;\nfloat tlVal = isSeenBySun( tl, vSunRelPosition.z, bias);\nfloat trVal = isSeenBySun( tl + vec2(1.0, 0.0) / uShadowTexDimensions, vSunRelPosition.z, bias);\nfloat blVal = isSeenBySun( tl + vec2(0.0, 1.0) / uShadowTexDimensions, vSunRelPosition.z, bias);\nfloat brVal = isSeenBySun( tl + vec2(1.0, 1.0) / uShadowTexDimensions, vSunRelPosition.z, bias);\nfloat occludedBySun = mix(\nmix(tlVal, trVal, pos.x),\nmix(blVal, brVal, pos.x),\npos.y);\ndiffuse *= 1.0 - (shadowStrength * (1.0 - occludedBySun));\n}\nvec3 color = vColor* texture2D( uWallTexIndex, vTexCoord.st).rgb +\n(diffuse/1.5) * uLightColor;\nfloat fogIntensity = (verticalDistanceToLowerEdge - uFogDistance) / uFogBlurDistance;\nfogIntensity = clamp(fogIntensity, 0.0, 1.0);\n//gl_FragColor = vec4( mix(color, uFogColor, fogIntensity), 1.0);\ngl_FragColor = vec4( color, 1.0-fogIntensity);\n}\n"},basemap:{vertex:"precision highp float; // is default in vertex shaders anyway, using highp fixes #49\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 uViewMatrix;\nuniform mat4 uModelMatrix;\nuniform vec2 uViewDirOnMap;\nuniform vec2 uLowerEdgePoint;\nvarying vec2 vTexCoord;\nvarying float verticalDistanceToLowerEdge;\nvoid main() {\ngl_Position = uViewMatrix * aPosition;\nvTexCoord = aTexCoord;\nvec4 worldPos = uModelMatrix * aPosition;\nvec2 dirFromLowerEdge = worldPos.xy / worldPos.w - uLowerEdgePoint;\nverticalDistanceToLowerEdge = dot(dirFromLowerEdge, uViewDirOnMap);\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D uTexIndex;\nuniform vec3 uFogColor;\nvarying vec2 vTexCoord;\nvarying float verticalDistanceToLowerEdge;\nuniform float uFogDistance;\nuniform float uFogBlurDistance;\nvoid main() {\nfloat fogIntensity = (verticalDistanceToLowerEdge - uFogDistance) / uFogBlurDistance;\nfogIntensity = clamp(fogIntensity, 0.0, 1.0);\ngl_FragColor = vec4(texture2D(uTexIndex, vec2(vTexCoord.x, 1.0-vTexCoord.y)).rgb, 1.0-fogIntensity);\n}\n"},basemap_with_shadows:{vertex:"precision highp float; //is default in vertex shaders anyway, using highp fixes #49\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nuniform mat4 uModelMatrix;\nuniform mat4 uMatrix;\nuniform mat4 uSunMatrix;\nuniform vec2 uViewDirOnMap;\nuniform vec2 uLowerEdgePoint;\n//varying vec2 vTexCoord;\nvarying vec3 vSunRelPosition;\nvarying vec3 vNormal;\nvarying float verticalDistanceToLowerEdge;\nvoid main() {\nvec4 pos = vec4(aPosition.xyz, 1.0);\ngl_Position = uMatrix * pos;\nvec4 sunRelPosition = uSunMatrix * pos;\nvSunRelPosition = (sunRelPosition.xyz / sunRelPosition.w + 1.0) / 2.0;\nvNormal = aNormal;\nvec4 worldPos = uModelMatrix * pos;\nvec2 dirFromLowerEdge = worldPos.xy / worldPos.w - uLowerEdgePoint;\nverticalDistanceToLowerEdge = dot(dirFromLowerEdge, uViewDirOnMap);\n}\n",fragment:"\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n/* This shader computes the diffuse brightness of the map layer. It does *not*\n* render the map texture itself, but is instead intended to be blended on top\n* of an already rendered map.\n* Note: this shader is not (and does not attempt to) be physically correct.\n* It is intented to be a blend between a useful illustration of cast\n* shadows and a mitigation of shadow casting artifacts occuring at\n* low angles on incidence.\n* Map brightness is only affected by shadows, not by light direction.\n* Shadows are darkest when light comes from straight above (and thus\n* shadows can be computed reliably) and become less and less visible\n* with the light source close to horizon (where moirC) and offset\n* artifacts would otherwise be visible).\n*/\n//uniform sampler2D uTexIndex;\nuniform sampler2D uShadowTexIndex;\nuniform vec3 uFogColor;\nuniform vec3 uDirToSun;\nuniform vec2 uShadowTexDimensions;\nuniform float uShadowStrength;\nvarying vec2 vTexCoord;\nvarying vec3 vSunRelPosition;\nvarying vec3 vNormal;\nvarying float verticalDistanceToLowerEdge;\nuniform float uFogDistance;\nuniform float uFogBlurDistance;\nfloat isSeenBySun( const vec2 sunViewNDC, const float depth, const float bias) {\nif ( clamp( sunViewNDC, 0.0, 1.0) != sunViewNDC) //not inside sun's viewport\nreturn 1.0;\n\nfloat depthFromTexture = texture2D( uShadowTexIndex, sunViewNDC.xy).x;\n\n//compare depth values not in reciprocal but in linear depth\nreturn step(1.0/depthFromTexture, 1.0/depth + bias);\n}\nvoid main() {\n//vec2 tl = floor(vSunRelPosition.xy * uShadowTexDimensions) / uShadowTexDimensions;\n//gl_FragColor = vec4(vec3(texture2D( uShadowTexIndex, tl).x), 1.0);\n//return;\nfloat diffuse = dot(uDirToSun, normalize(vNormal));\ndiffuse = max(diffuse, 0.0);\n\nfloat shadowStrength = uShadowStrength * pow(diffuse, 1.5);\nif (diffuse > 0.0) {\n// note: the diffuse term is also the cosine between the surface normal and the\n// light direction\nfloat bias = clamp(0.0007*tan(acos(diffuse)), 0.0, 0.01);\n\nvec2 pos = fract( vSunRelPosition.xy * uShadowTexDimensions);\n\nvec2 tl = floor(vSunRelPosition.xy * uShadowTexDimensions) / uShadowTexDimensions;\nfloat tlVal = isSeenBySun( tl, vSunRelPosition.z, bias);\nfloat trVal = isSeenBySun( tl + vec2(1.0, 0.0) / uShadowTexDimensions, vSunRelPosition.z, bias);\nfloat blVal = isSeenBySun( tl + vec2(0.0, 1.0) / uShadowTexDimensions, vSunRelPosition.z, bias);\nfloat brVal = isSeenBySun( tl + vec2(1.0, 1.0) / uShadowTexDimensions, vSunRelPosition.z, bias);\ndiffuse = mix( mix(tlVal, trVal, pos.x),\nmix(blVal, brVal, pos.x),\npos.y);\n}\ndiffuse = mix(1.0, diffuse, shadowStrength);\n\nfloat fogIntensity = (verticalDistanceToLowerEdge - uFogDistance) / uFogBlurDistance;\nfogIntensity = clamp(fogIntensity, 0.0, 1.0);\nfloat darkness = (1.0 - diffuse);\ndarkness *= (1.0 - fogIntensity);\ngl_FragColor = vec4(vec3(1.0 - darkness), 1.0);\n}\n"},texture:{vertex:"precision highp float; //is default in vertex shaders anyway, using highp fixes #49\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 uMatrix;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_Position = uMatrix * aPosition;\nvTexCoord = aTexCoord;\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D uTexIndex;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = vec4(texture2D(uTexIndex, vTexCoord.st).rgb, 1.0);\n}\n"},depth_normal:{vertex:"precision highp float; //is default in vertex shaders anyway, using highp fixes #49\nattribute vec4 aPosition;\nattribute vec3 aNormal;\nattribute float aZScale;\nuniform mat4 uMatrix;\nuniform mat4 uModelMatrix;\nuniform mat3 uNormalMatrix;\nuniform vec2 uViewDirOnMap;\nuniform vec2 uLowerEdgePoint;\nuniform float uFade;\nvarying float verticalDistanceToLowerEdge;\nvarying vec3 vNormal;\nvoid main() {\nfloat f = clamp(uFade*aZScale, 0.0, 1.0);\nif (f == 0.0) {\ngl_Position = vec4(0.0, 0.0, 0.0, 0.0);\nverticalDistanceToLowerEdge = 0.0;\n} else {\nvec4 pos = vec4(aPosition.x, aPosition.y, aPosition.z*f, aPosition.w);\ngl_Position = uMatrix * pos;\nvNormal = uNormalMatrix * aNormal;\nvec4 worldPos = uModelMatrix * pos;\nvec2 dirFromLowerEdge = worldPos.xy / worldPos.w - uLowerEdgePoint;\nverticalDistanceToLowerEdge = dot(dirFromLowerEdge, uViewDirOnMap);\n}\n}\n",fragment:"\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float uFogDistance;\nuniform float uFogBlurDistance;\nvarying float verticalDistanceToLowerEdge;\nvarying vec3 vNormal;\nvoid main() {\nfloat fogIntensity = (verticalDistanceToLowerEdge - uFogDistance) / uFogBlurDistance;\ngl_FragColor = vec4(normalize(vNormal) / 2.0 + 0.5, clamp(fogIntensity, 0.0, 1.0));\n}\n"},ambient_from_depth:{vertex:"precision highp float; //is default in vertex shaders anyway, using highp fixes #49\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_Position = aPosition;\nvTexCoord = aTexCoord;\n}\n",fragment:"#ifdef GL_FRAGMENT_PRECISION_HIGH\n// we need high precision for the depth values\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform sampler2D uDepthTexIndex;\nuniform sampler2D uFogTexIndex;\nuniform vec2 uInverseTexSize; //in 1/pixels, e.g. 1/512 if the texture is 512px wide\nuniform float uEffectStrength;\nuniform float uNearPlane;\nuniform float uFarPlane;\nvarying vec2 vTexCoord;\n/* Retrieves the depth value 'offset' pixels away from 'pos' from texture 'uDepthTexIndex'. */\nfloat getDepth(vec2 pos, ivec2 offset)\n{\nfloat z = texture2D(uDepthTexIndex, pos + float(offset) * uInverseTexSize).x;\nreturn (2.0 * uNearPlane) / (uFarPlane + uNearPlane - z * (uFarPlane - uNearPlane)); // linearize depth\n}\n/* getOcclusionFactor() determines a heuristic factor (from [0..1]) for how\n* much the fragment at 'pos' with depth 'depthHere'is occluded by the\n* fragment that is (dx, dy) texels away from it.\n*/\nfloat getOcclusionFactor(float depthHere, vec2 pos, ivec2 offset) {\nfloat depthThere = getDepth(pos, offset);\n/* if the fragment at (dx, dy) has no depth (i.e. there was nothing rendered there),\n* then 'here' is not occluded (result 1.0) */\nif (depthThere == 0.0)\nreturn 1.0;\n/* if the fragment at (dx, dy) is further away from the viewer than 'here', then\n* 'here is not occluded' */\nif (depthHere < depthThere )\nreturn 1.0;\nfloat relDepthDiff = depthThere / depthHere;\nfloat depthDiff = abs(depthThere - depthHere) * uFarPlane;\n/* if the fragment at (dx, dy) is closer to the viewer than 'here', then it occludes\n* 'here'. The occlusion is the higher the bigger the depth difference between the two\n* locations is.\n* However, if the depth difference is too high, we assume that 'there' lies in a\n* completely different depth region of the scene than 'here' and thus cannot occlude\n* 'here'. This last assumption gets rid of very dark artifacts around tall buildings.\n*/\nreturn depthDiff < 50.0 ? mix(0.99, 1.0, 1.0 - clamp(depthDiff, 0.0, 1.0)) : 1.0;\n}\n/* This shader approximates the ambient occlusion in screen space (SSAO).\n* It is based on the assumption that a pixel will be occluded by neighboring\n* pixels iff. those have a depth value closer to the camera than the original\n* pixel itself (the function getOcclusionFactor() computes this occlusion\n* by a single other pixel).\n*\n* A naive approach would sample all pixels within a given distance. For an\n* interesting-looking effect, the sampling area needs to be at least 9 pixels\n* wide (-/+ 4), requiring 81 texture lookups per pixel for ambient occlusion.\n* This overburdens many GPUs.\n* To make the ambient occlusion computation faster, we do not consider all\n* texels in the sampling area, but only 16. This causes some sampling artifacts\n* that are later removed by blurring the ambient occlusion texture (this is\n* done in a separate shader).\n*/\nvoid main() {\nfloat depthHere = getDepth(vTexCoord, ivec2(0, 0));\nfloat fogIntensity = texture2D(uFogTexIndex, vTexCoord).w;\nif (depthHere == 0.0)\n{\n\t//there was nothing rendered 'here' --\x3e it can't be occluded\ngl_FragColor = vec4(1.0);\nreturn;\n}\nfloat occlusionFactor = 1.0;\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(-1, 0));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(+1, 0));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2( 0, -1));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2( 0, +1));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(-2, -2));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(+2, +2));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(+2, -2));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(-2, +2));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(-4, 0));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(+4, 0));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2( 0, -4));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2( 0, +4));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(-4, -4));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(+4, +4));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(+4, -4));\nocclusionFactor *= getOcclusionFactor(depthHere, vTexCoord, ivec2(-4, +4));\nocclusionFactor = pow(occlusionFactor, 4.0) + 55.0/255.0; // empirical bias determined to let SSAO have no effect on the map plane\nocclusionFactor = 1.0 - ((1.0 - occlusionFactor) * uEffectStrength * (1.0-fogIntensity));\ngl_FragColor = vec4(vec3(occlusionFactor), 1.0);\n}\n"},flat_color:{vertex:"precision highp float; // is default in vertex shaders anyway, using highp fixes #49\nattribute vec4 aPosition;\nuniform mat4 uMatrix;\nvoid main() {\ngl_Position = uMatrix * aPosition;\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform vec4 uColor;\nvoid main() {\ngl_FragColor = uColor;\n}\n"},horizon:{vertex:"precision highp float; // is default in vertex shaders anyway, using highp fixes #49\n#define halfPi 1.57079632679\nattribute vec4 aPosition;\nuniform mat4 uMatrix;\nuniform float uAbsoluteHeight;\nvarying vec2 vTexCoord;\nvarying float vRelativeHeight;\nvoid main() {\ngl_Position = uMatrix * aPosition;\nvRelativeHeight = aPosition.z / uAbsoluteHeight;\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform vec3 uFogColor;\nvarying float vRelativeHeight;\nvoid main() {\nfloat blendFactor = min(100.0 * vRelativeHeight, 1.0);\nvec4 skyColor = vec4(0.9, 0.85, 1.0, 1.0);\ngl_FragColor = mix(vec4(uFogColor, 1.0), skyColor, blendFactor);\n}\n"},blur:{vertex:"precision highp float; // is default in vertex shaders anyway, using highp fixes #49\nattribute vec4 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_Position = aPosition;\nvTexCoord = aTexCoord;\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D uTexIndex;\nuniform vec2 uInverseTexSize; // as 1/n pixels, e.g. 1/512 if the texture is 512px wide\nvarying vec2 vTexCoord;\n// Retrieves the texel color 'offset' pixels away from 'pos' from texture 'uTexIndex'.\nvec4 getTexel(vec2 pos, vec2 offset) {\nreturn texture2D(uTexIndex, pos + offset * uInverseTexSize);\n}\nvoid main() {\nvec4 center = texture2D(uTexIndex, vTexCoord);\nvec4 nonDiagonalNeighbors = getTexel(vTexCoord, vec2(-1.0, 0.0)) +\ngetTexel(vTexCoord, vec2(+1.0, 0.0)) +\ngetTexel(vTexCoord, vec2( 0.0, -1.0)) +\ngetTexel(vTexCoord, vec2( 0.0, +1.0));\nvec4 diagonalNeighbors = getTexel(vTexCoord, vec2(-1.0, -1.0)) +\ngetTexel(vTexCoord, vec2(+1.0, +1.0)) +\ngetTexel(vTexCoord, vec2(-1.0, +1.0)) +\ngetTexel(vTexCoord, vec2(+1.0, -1.0));\n\n// approximate Gaussian blur (mean 0.0, stdev 1.0)\ngl_FragColor = 0.2/1.0 * center +\n0.5/4.0 * nonDiagonalNeighbors +\n0.3/4.0 * diagonalNeighbors;\n}\n"},marker:{vertex:"precision highp float; // is default in vertex shaders anyway, using highp fixes #49\nattribute vec4 aPosition;\n// uniform mat4 uMatrix;\nuniform mat4 uProjMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uModelMatrix;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nuniform float markerSize;\nvoid main() {\nmat4 modelView = uViewMatrix * uModelMatrix;\nmodelView[0][0] = 1.0;\nmodelView[0][1] = 0.0;\nmodelView[0][2] = 0.0;\nmodelView[1][0] = 0.0;\nmodelView[1][1] = 1.0;\nmodelView[1][2] = 0.0;\nmodelView[2][0] = 0.0;\nmodelView[2][1] = 0.0;\nmodelView[2][2] = 1.0;\nmat4 mvp = uProjMatrix * modelView;\nfloat reciprScaleOnscreen = 0.02;\nfloat w = (mvp * vec4(0,0,0,1)).w;\nw *= reciprScaleOnscreen;\n// marker size is needed for a new offset after scaling the marker\nvec4 pos = vec4((aPosition.x * w), (aPosition.y * w) - (markerSize/2.0*w), aPosition.z * w , 1);\ngl_Position = mvp * pos;\nvTexCoord = aTexCoord;\n}\n",fragment:"#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform sampler2D uTexIndex;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexIndex, vTexCoord);\n}\n"}};class r{constructor(e,t){let i;const r={antialias:!t,depth:!0,premultipliedAlpha:!1};try{i=e.getContext("webgl",r)}catch(e){}if(!i)try{i=e.getContext("experimental-webgl",r)}catch(e){}if(!i)throw new Error("GL not supported");e.addEventListener("webglcontextlost",e=>{console.warn("context lost")}),e.addEventListener("webglcontextrestored",e=>{console.warn("context restored")}),i.viewport(0,0,e.width,e.height),i.cullFace(i.BACK),i.enable(i.CULL_FACE),i.enable(i.DEPTH_TEST),i.clearColor(.5,.5,.5,1),t||(i.anisotropyExtension=i.getExtension("EXT_texture_filter_anisotropic"),i.anisotropyExtension&&(i.anisotropyExtension.maxAnisotropyLevel=i.getParameter(i.anisotropyExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),i.depthTextureExtension=i.getExtension("WEBGL_depth_texture")),this.GL=i}destroy(){this.GL.getExtension("WEBGL_lose_context").loseContext(),this.GL=null}}r.Buffer=class{constructor(e,t){this.id=l.createBuffer(),this.itemSize=e,this.numItems=t.length/e,l.bindBuffer(l.ARRAY_BUFFER,this.id),l.bufferData(l.ARRAY_BUFFER,t,l.STATIC_DRAW),t=null}enable(){l.bindBuffer(l.ARRAY_BUFFER,this.id)}use(){l.bindBuffer(l.ARRAY_BUFFER,this.id)}destroy(){l.deleteBuffer(this.id),this.id=null}},r.Framebuffer=class{constructor(e,t,i){if(i&&!l.depthTextureExtension)throw new Error("GL: Depth textures are not supported");this.useDepthTexture=!!i,this.setSize(e,t)}setSize(e,t){if(this.frameBuffer){if(e===this.width&&t===this.height)return}else this.frameBuffer=l.createFramebuffer();if(l.bindFramebuffer(l.FRAMEBUFFER,this.frameBuffer),this.width=e,this.height=t,this.depthRenderBuffer&&(l.deleteRenderbuffer(this.depthRenderBuffer),this.depthRenderBuffer=null),this.depthTexture&&(this.depthTexture.destroy(),this.depthTexture=null),this.useDepthTexture?(this.depthTexture=new r.texture.Image,this.depthTexture.enable(0),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MAG_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),l.texImage2D(l.TEXTURE_2D,0,l.DEPTH_STENCIL,e,t,0,l.DEPTH_STENCIL,l.depthTextureExtension.UNSIGNED_INT_24_8_WEBGL,null),l.framebufferTexture2D(l.FRAMEBUFFER,l.DEPTH_STENCIL_ATTACHMENT,l.TEXTURE_2D,this.depthTexture.id,0)):(this.depthRenderBuffer=l.createRenderbuffer(),l.bindRenderbuffer(l.RENDERBUFFER,this.depthRenderBuffer),l.renderbufferStorage(l.RENDERBUFFER,l.DEPTH_COMPONENT16,e,t),l.framebufferRenderbuffer(l.FRAMEBUFFER,l.DEPTH_ATTACHMENT,l.RENDERBUFFER,this.depthRenderBuffer)),this.renderTexture&&this.renderTexture.destroy(),this.renderTexture=new r.texture.Data(l,e,t),l.bindTexture(l.TEXTURE_2D,this.renderTexture.id),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,this.renderTexture.id,0),l.checkFramebufferStatus(l.FRAMEBUFFER)!==l.FRAMEBUFFER_COMPLETE)throw new Error("Combination of framebuffer attachments doesn't work");l.bindRenderbuffer(l.RENDERBUFFER,null),l.bindFramebuffer(l.FRAMEBUFFER,null)}enable(){l.bindFramebuffer(l.FRAMEBUFFER,this.frameBuffer),this.useDepthTexture||l.bindRenderbuffer(l.RENDERBUFFER,this.depthRenderBuffer)}disable(){l.bindFramebuffer(l.FRAMEBUFFER,null),this.useDepthTexture||l.bindRenderbuffer(l.RENDERBUFFER,null)}getPixel(e,t){if(e<0||t<0||e>=this.width||t>=this.height)return;const i=new Uint8Array(4);return l.readPixels(e,t,1,1,l.RGBA,l.UNSIGNED_BYTE,i),i}getData(){const e=new Uint8Array(this.width*this.height*4);return l.readPixels(0,0,this.width,this.height,l.RGBA,l.UNSIGNED_BYTE,e),e}destroy(){this.renderTexture&&this.renderTexture.destroy(),this.depthTexture&&this.depthTexture.destroy()}},r.Shader=class{constructor(e){if(this.shaderName=e.shaderName,this.id=l.createProgram(),this.compile(l.VERTEX_SHADER,e.vertexShader),this.compile(l.FRAGMENT_SHADER,e.fragmentShader),l.linkProgram(this.id),!l.getProgramParameter(this.id,l.LINK_STATUS))throw new Error(l.getProgramParameter(this.id,l.VALIDATE_STATUS)+"\n"+l.getError());l.useProgram(this.id),this.attributes={},(e.attributes||[]).forEach(e=>{this.locateAttribute(e)}),this.uniforms={},(e.uniforms||[]).forEach(e=>{this.locateUniform(e)})}locateAttribute(e){const t=l.getAttribLocation(this.id,e);if(t<0)throw new Error(`unable to locate attribute "${e}" in shader "${this.shaderName}"`);this.attributes[e]=t}locateUniform(e){const t=l.getUniformLocation(this.id,e);if(!t)throw new Error(`unable to locate uniform "${e}" in shader "${this.shaderName}"`);this.uniforms[e]=t}compile(e,t){const i=l.createShader(e);if(l.shaderSource(i,t),l.compileShader(i),!l.getShaderParameter(i,l.COMPILE_STATUS))throw new Error(l.getShaderInfoLog(i));l.attachShader(this.id,i)}enable(){l.useProgram(this.id);for(let e in this.attributes)l.enableVertexAttribArray(this.attributes[e]);return this}disable(){if(this.attributes)for(let e in this.attributes)l.disableVertexAttribArray(this.attributes[e])}setBuffer(e,t){if(void 0===this.attributes[e])throw new Error(`attempt to bind buffer to invalid attribute "${e}" in shader "${this.shaderName}"`);t.enable(),l.vertexAttribPointer(this.attributes[e],t.itemSize,l.FLOAT,!1,0,0)}setParam(e,t,i){if(void 0===this.uniforms[e])throw new Error(`attempt to bind to invalid uniform "${e}" in shader "${this.shaderName}"`);l["uniform"+t](this.uniforms[e],i)}setMatrix(e,t,i){if(void 0===this.uniforms[e])throw new Error(`attempt to bind to invalid uniform "${e}" in shader "${this.shaderName}"`);l["uniformMatrix"+t](this.uniforms[e],!1,i)}setTexture(e,t,i){i.enable(t),this.setParam(e,"1i",t)}destroy(){this.disable(),this.id=null}},r.Matrix=function(e){this.data=new Float32Array(e||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])},r.Matrix.identity=function(){return new r.Matrix([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])},r.Matrix.identity3=function(){return new r.Matrix([1,0,0,0,1,0,0,0,1])},function(){function e(e){return e*Math.PI/180}function t(e,t,i){var r=t[0],o=t[1],n=t[2],a=t[3],s=t[4],u=t[5],h=t[6],l=t[7],d=t[8],f=t[9],c=t[10],m=t[11],g=t[12],x=t[13],v=t[14],p=t[15],w=i[0],T=i[1],A=i[2],b=i[3],E=i[4],M=i[5],y=i[6],P=i[7],D=i[8],B=i[9],S=i[10],C=i[11],F=i[12],R=i[13],_=i[14],I=i[15];e[0]=r*w+o*E+n*D+a*F,e[1]=r*T+o*M+n*B+a*R,e[2]=r*A+o*y+n*S+a*_,e[3]=r*b+o*P+n*C+a*I,e[4]=s*w+u*E+h*D+l*F,e[5]=s*T+u*M+h*B+l*R,e[6]=s*A+u*y+h*S+l*_,e[7]=s*b+u*P+h*C+l*I,e[8]=d*w+f*E+c*D+m*F,e[9]=d*T+f*M+c*B+m*R,e[10]=d*A+f*y+c*S+m*_,e[11]=d*b+f*P+c*C+m*I,e[12]=g*w+x*E+v*D+p*F,e[13]=g*T+x*M+v*B+p*R,e[14]=g*A+x*y+v*S+p*_,e[15]=g*b+x*P+v*C+p*I}r.Matrix.prototype={multiply:function(e){return t(this.data,this.data,e.data),this},translate:function(e,i,r){return t(this.data,this.data,[1,0,0,0,0,1,0,0,0,0,1,0,e,i,r,1]),this},rotateX:function(i){var r=e(i),o=Math.cos(r),n=Math.sin(r);return t(this.data,this.data,[1,0,0,0,0,o,n,0,0,-n,o,0,0,0,0,1]),this},rotateY:function(i){var r=e(i),o=Math.cos(r),n=Math.sin(r);return t(this.data,this.data,[o,0,-n,0,0,1,0,0,n,0,o,0,0,0,0,1]),this},rotateZ:function(i){var r=e(i),o=Math.cos(r),n=Math.sin(r);return t(this.data,this.data,[o,-n,0,0,n,o,0,0,0,0,1,0,0,0,0,1]),this},scale:function(e,i,r){return t(this.data,this.data,[e,0,0,0,0,i,0,0,0,0,r,0,0,0,0,1]),this}},r.Matrix.multiply=function(e,i){var r=new Float32Array(16);return t(r,e.data,i.data),r},r.Matrix.Perspective=function(e,t,i,o){var n=1/Math.tan(e*(Math.PI/180)/2),a=1/(i-o);return new r.Matrix([n/t,0,0,0,0,n,0,0,0,0,(o+i)*a,-1,0,0,2*o*i*a,0])},r.Matrix.Frustum=function(e,t,i,o,n,a){var s=1/(t-e),u=1/(i-o),h=1/(n-a);return new r.Matrix([2*n*s,0,0,0,0,2*n*u,0,0,(t+e)*s,(i+o)*u,(a+n)*h,-1,0,0,a*n*2*h,0])},r.Matrix.OffCenterProjection=function(e,t,i,o,n,a){var s=ue(oe(i,e)),u=ue(oe(t,e)),h=function(e,t,i){var r=oe(e,t),o=oe(t,i);return ue([r[1]*o[2]-r[2]*o[1],r[2]*o[0]-r[0]*o[2],r[0]*o[1]-r[1]*o[0]])}(e,t,i),l=oe(e,o),d=oe(t,o),f=oe(i,o),c=-re(l,h),m=re(s,l)*n/c,g=re(s,f)*n/c,x=re(u,l)*n/c,v=re(u,d)*n/c;return r.Matrix.Frustum(m,g,v,x,n,a)},r.Matrix.Ortho=function(e,t,i,o,n,a){return new r.Matrix([2/(t-e),0,0,0,0,2/(i-o),0,0,0,0,-2/(a-n),0,-(t+e)/(t-e),-(i+o)/(i-o),-(a+n)/(a-n),1])},r.Matrix.invert3=function(e){var t=e[0],i=e[1],r=e[2],o=e[4],n=e[5],a=e[6],s=e[8],u=e[9],h=e[10],l=h*n-a*u,d=-h*o+a*s,f=u*o-n*s,c=t*l+i*d+r*f;return c?[l*(c=1/c),(-h*i+r*u)*c,(a*i-r*n)*c,d*c,(h*t-r*s)*c,(-a*t+r*o)*c,f*c,(-u*t+i*s)*c,(n*t-i*o)*c]:null},r.Matrix.transpose3=function(e){return new Float32Array([e[0],e[3],e[6],e[1],e[4],e[7],e[2],e[5],e[8]])},r.Matrix.transpose=function(e){return new Float32Array([e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]])},r.Matrix.transform=function(e){const t=e[12],i=e[13],r=e[14],o=e[15];return{x:(t/o+1)/2,y:(i/o+1)/2,z:(r/o+1)/2}},r.Matrix.invert=function(e){const t=new Float32Array(16),i=e[0],r=e[1],o=e[2],n=e[3],a=e[4],s=e[5],u=e[6],h=e[7],l=e[8],d=e[9],f=e[10],c=e[11],m=e[12],g=e[13],x=e[14],v=e[15],p=i*s-r*a,w=i*u-o*a,T=i*h-n*a,A=r*u-o*s,b=r*h-n*s,E=o*h-n*u,M=l*g-d*m,y=l*x-f*m,P=l*v-c*m,D=d*x-f*g,B=d*v-c*g,S=f*v-c*x;let C=p*S-w*B+T*D+A*P-b*y+E*M;if(C)return C=1/C,t[0]=(s*S-u*B+h*D)*C,t[1]=(o*B-r*S-n*D)*C,t[2]=(g*E-x*b+v*A)*C,t[3]=(f*b-d*E-c*A)*C,t[4]=(u*P-a*S-h*y)*C,t[5]=(i*S-o*P+n*y)*C,t[6]=(x*T-m*E-v*w)*C,t[7]=(l*E-f*T+c*w)*C,t[8]=(a*B-s*P+h*M)*C,t[9]=(r*P-i*B-n*M)*C,t[10]=(m*b-g*T+v*p)*C,t[11]=(d*T-l*b-c*p)*C,t[12]=(s*y-a*D-u*M)*C,t[13]=(i*D-r*y+o*M)*C,t[14]=(g*w-m*A-x*p)*C,t[15]=(l*A-d*w+f*p)*C,t}}(),r.texture={},r.texture.Image=class{constructor(){this.id=l.createTexture(),l.bindTexture(l.TEXTURE_2D,this.id),l.bindTexture(l.TEXTURE_2D,null)}clamp(e,t){if(e.width<=t&&e.height<=t)return e;let i=t,r=t;const o=e.width/e.height;o<1?i=Math.round(r*o):r=Math.round(i/o);const n=M.createElement("CANVAS");return n.width=i,n.height=r,n.getContext("2d").drawImage(e,0,0,n.width,n.height),n}load(e,t){const i=new Image;return i.crossOrigin="*",i.onload=(e=>{this.set(i),t&&t(i)}),i.onerror=(e=>{t&&t()}),i.src=e,this}color(e){return l.bindTexture(l.TEXTURE_2D,this.id),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.LINEAR),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MAG_FILTER,l.LINEAR),l.texImage2D(l.TEXTURE_2D,0,l.RGBA,1,1,0,l.RGBA,l.UNSIGNED_BYTE,new Uint8Array([255*e[0],255*e[1],255*e[2],255*(void 0===e[3]?1:e[3])])),l.bindTexture(l.TEXTURE_2D,null),this}set(e){if(this.id)return e=this.clamp(e,l.getParameter(l.MAX_TEXTURE_SIZE)),l.bindTexture(l.TEXTURE_2D,this.id),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.LINEAR_MIPMAP_NEAREST),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MAG_FILTER,l.LINEAR),l.texImage2D(l.TEXTURE_2D,0,l.RGBA,l.RGBA,l.UNSIGNED_BYTE,e),l.generateMipmap(l.TEXTURE_2D),l.anisotropyExtension&&l.texParameterf(l.TEXTURE_2D,l.anisotropyExtension.TEXTURE_MAX_ANISOTROPY_EXT,l.anisotropyExtension.maxAnisotropyLevel),l.bindTexture(l.TEXTURE_2D,null),this}enable(e){if(this.id)return l.activeTexture(l.TEXTURE0+(e||0)),l.bindTexture(l.TEXTURE_2D,this.id),this}destroy(){l.bindTexture(l.TEXTURE_2D,null),l.deleteTexture(this.id),this.id=null}},r.texture.Data=class{constructor(e,t,i,r){this.id=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.id),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST);let o=null;if(r){const e=t*i*4;(o=new Uint8Array(e)).set(r.subarray(0,e))}e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,i,0,e.RGBA,e.UNSIGNED_BYTE,o),e.bindTexture(e.TEXTURE_2D,null),this.GL=e}enable(e){return this.GL.activeTexture(this.GL.TEXTURE0+(e||0)),this.GL.bindTexture(this.GL.TEXTURE_2D,this.id),this}destroy(){this.GL.bindTexture(this.GL.TEXTURE_2D,null),this.GL.deleteTexture(this.id),this.id=null}};class o{constructor(){this.items=[]}add(e){this.items.push(e)}remove(e){this.items=this.items.filter(t=>t!==e)}forEach(e){this.items.forEach(e)}destroy(){this.forEach(e=>e.destroy()),this.items=[]}}class n{constructor(e={}){this.offsetX=e.offsetX||0,this.offsetY=e.offsetY||0,this.position=e.position||{latitude:0,longitude:0},this.elevation=e.elevation||30,this.source=e.source,this.isReady=!1,this.size=e.size||1,h.markers.add(this),this.load()}load(){const e=this.size/2,t=this.size/2,i=[-e,-t,0,e,-t,0,-e,t,0,e,t,0,-e,t,0,e,-t,0];this.texCoordBuffer=new r.Buffer(2,new Float32Array([0,0,1,0,0,1,1,1,0,1,1,0])),this.vertexBuffer=new r.Buffer(3,new Float32Array(i)),this.source?this.texture=(new r.texture.Image).load(this.source,e=>{e?(l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),l.bindTexture(l.TEXTURE_2D,this.texture.id),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.LINEAR),this.isReady=!0):(console.log("can not read marker source"),this.loadStandardIcon())}):(console.log("no marker source"),this.loadStandardIcon())}loadStandardIcon(){this.texture=(new r.texture.Image).load(S,e=>{e&&(l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),l.bindTexture(l.TEXTURE_2D,this.texture.id),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.LINEAR),this.isReady=!0,this.source="Standard Icon")})}destroy(){h.markers.remove(this),this.texCoordBuffer.destroy(),this.vertexBuffer.destroy(),this.isReady&&this.texture.destroy()}}class s{constructor(e,t){this.items=[];for(let i=0;i<t;i++)this.items[i]=new u(e)}get(e){for(let t=0;t<this.items.length;t++)if(!this.items[t].busy)return this.items[t].busy=!0,void e(this.items[t]);setTimeout(()=>{this.get(e)},50)}destroy(){this.items.forEach(e=>e.destroy()),this.items=[]}}class u{constructor(e){this.busy=!1,this.thread=new Worker(e)}postMessage(e){this.thread.postMessage(e)}onMessage(e){this.thread.onmessage=function(t){e(t.data)}}free(){this.thread.onmessage=function(e){},this.busy=!1}destroy(){this.thread.close()}}let h,l;class d{constructor(t={}){h=this,t.style&&(t.style.color||t.style.wallColor)&&e.parse(t.style.color||t.style.wallColor).toArray(),le.backgroundColor=e.parse(t.backgroundColor||E).toArray(),le.fogColor=e.parse(t.fogColor||b).toArray(),this.attribution=t.attribution||d.ATTRIBUTION,this.minZoom=Math.max(parseFloat(t.minZoom||v),v),this.maxZoom=Math.min(parseFloat(t.maxZoom||p),p),this.maxZoom<this.minZoom&&(this.minZoom=v,this.maxZoom=p),this.bounds=t.bounds,this.position=t.position||{latitude:52.52,longitude:13.41},this.zoom=t.zoom||this.minZoom+(this.maxZoom-this.minZoom)/2,this.rotation=t.rotation||0,this.tilt=t.tilt||0,t.disabled&&this.setDisabled(!0);const i=Math.min(window.navigator.hardwareConcurrency,4);this.workers=new s("./../src/workers/worker.js",4*i);let n=t.container;"string"==typeof n&&(n=M.getElementById(t.container)),this.container=M.createElement("DIV"),this.container.className="osmb",0===n.offsetHeight&&(n.style.height="100%",console.warn("Container height should be set. Now defaults to 100%.")),n.appendChild(this.container),this.canvas=M.createElement("CANVAS"),this.canvas.className="osmb-viewport";this.canvas.width=this.width=1*n.offsetWidth,this.canvas.height=this.height=1*n.offsetHeight,this.container.appendChild(this.canvas),this.glx=new r(this.canvas,t.fastMode),l=this.glx.GL,this.features=new U,this.markers=new o,this.events=new x(this.canvas),this._getStateFromUrl(),t.state&&(this._setStateToUrl(),this.events.on("change",e=>{this._setStateToUrl()})),this._attribution=M.createElement("DIV"),this._attribution.className="osmb-attribution",this.container.appendChild(this._attribution),this._updateAttribution(),this.setDate(new Date),le.start(),this.emit("load",this)}appendTo(){}on(e,t){this.events.on(e,t)}off(e,t){this.events.off(e,t)}emit(e,t){this.events.emit(e,t)}setDate(e){fe.setDate("string"==typeof e?new Date(e):e)}project(e,t,i){const r=P*Math.cos(this.position.latitude/180*Math.PI),o=[(t-this.position.longitude)*r,-(e-this.position.latitude)*P,i];let n=V(le.viewProjMatrix.data,o);return{x:(n=ae(ne(n,[1,1,1]),.5))[0]*this.width,y:(1-n[1])*this.height,z:n[2]}}unproject(e,t){const i=r.Matrix.invert(le.viewProjMatrix.data);let o=[e/this.width,1-t/this.height];const n=X((o=f(c(o,2),[-1,-1,-1]))[0],o[1],i);if(void 0===n)return;const a=P*Math.cos(this.position.latitude/180*Math.PI);return{latitude:this.position.latitude-n[1]/P,longitude:this.position.longitude+n[0]/a}}remove(e){e.destroy&&e.destroy()}addOBJ(e,t,i={}){return i.position=t,new G("OBJ",e,i)}addGeoJSON(e,t){return new G("GeoJSON",e,t)}addGeoJSONTiles(e,t={}){return t.fixedZoom=t.fixedZoom||15,this.dataGrid=new _(e,N,t,2),this.dataGrid}addMapTiles(e){return this.basemapGrid=new _(e,L,{},4),this.basemapGrid}highlight(e){this.features.setTintCallback(e)}hide(e){this.features.setZScaleCallback(e)}show(){}getTarget(){}screenshot(){}_updateAttribution(){const e=[];this.attribution&&e.push(this.attribution),this._attribution.innerHTML=e.join(" · ")}_getStateFromUrl(){const e=location.search,t={};e&&e.substring(1).replace(/(?:^|&)([^&=]*)=?([^&]*)/g,(e,i,r)=>{i&&(t[i]=r)}),this.setPosition(void 0!==t.lat&&void 0!==t.lon?{latitude:t.lat,longitude:t.lon}:this.position),this.setZoom(void 0!==t.zoom?t.zoom:this.zoom),this.setRotation(void 0!==t.rotation?t.rotation:this.rotation),this.setTilt(void 0!==t.tilt?t.tilt:this.tilt)}_setStateToUrl(){history.replaceState&&!this.stateDebounce&&(this.stateDebounce=setTimeout(()=>{this.stateDebounce=null;const e=[];e.push("lat="+this.position.latitude.toFixed(6)),e.push("lon="+this.position.longitude.toFixed(6)),e.push("zoom="+this.zoom.toFixed(1)),e.push("tilt="+this.tilt.toFixed(1)),e.push("rotation="+this.rotation.toFixed(1)),history.replaceState({},"","?"+e.join("&"))},1e3))}setDisabled(e){this.events.isDisabled=!!e}isDisabled(){return!!this.events.isDisabled}getBounds(){return le.getViewQuad().map(e=>j(e))}setZoom(e,t){e=parseFloat(e),e=Math.max(e,this.minZoom),e=Math.min(e,this.maxZoom),this.zoom!==e&&(this.zoom=e,this.events.emit("zoom",{zoom:e}),this.events.emit("change"))}getZoom(){return this.zoom}setPosition(e){const t=parseFloat(e.latitude),i=parseFloat(e.longitude);isNaN(t)||isNaN(i)||(this.position={latitude:R(t,-90,90),longitude:R(i,-180,180)},this.events.emit("change"))}getPosition(){return this.position}setSize(e,t){e===this.width&&t===this.height||(this.width=e,this.height=t,this.events.emit("resize",{width:this.width,height:this.height}))}getSize(){return{width:this.width,height:this.height}}setRotation(e){e=parseFloat(e)%360,this.rotation!==e&&(this.rotation=e,this.events.emit("rotate",{rotation:e}),this.events.emit("change"))}getRotation(){return this.rotation}setTilt(e){e=R(parseFloat(e),0,w),this.tilt!==e&&(this.tilt=e,this.events.emit("tilt",{tilt:e}),this.events.emit("change"))}getTilt(){return this.tilt}addMarker(e){return new n(e)}destroy(){le.destroy(),this.events.destroy(),this.glx.destroy(),this.canvas.parentNode.removeChild(this.canvas),this.features.destroy(),this.markers.destroy(),this.container.innerHTML=""}}function f(e,t){return[e[0]+t[0],e[1]+t[1]]}function c(e,t){return[e[0]*t,e[1]*t]}function m(e){const t=e.target.getBoundingClientRect();return{x:e.x-t.left,y:e.y-t.top}}function g(e,t,i){e.addEventListener(t,i,!1)}d.VERSION="4.0.0",d.ATTRIBUTION='<a href="https://osmbuildings.org/">© OSM Buildings</a>',"function"==typeof define?define([],d):"object"==typeof module?module.exports=d:window.OSMBuildings=d;class x{constructor(e){this.window=top||window,this.listeners={},this.isDisabled=!1,this.prevX=0,this.prevY=0,this.startZoom=0,this.prevRotation=0,this.prevTilt=0,this.startDist=0,this.startAngle=0,this.buttons=0,this.addAllListeners(this.window,e)}addAllListeners(e,t){const i=e.document;let r;"ontouchstart"in e?(g(t,"touchstart",e=>{this.onTouchStart(e)}),g(i,"touchmove",e=>{this.onTouchMoveDocument(e)}),g(t,"touchmove",e=>{this.onTouchMove(e)}),g(i,"touchend",e=>{this.onTouchEndDocument(e)}),g(i,"gesturechange",e=>{this.onGestureChangeDocument(e)})):(g(t,"mousedown",e=>{this.onMouseDown(e)}),g(i,"mousemove",e=>{this.onMouseMoveDocument(e)}),g(t,"mousemove",e=>{this.onMouseMove(e)}),g(i,"mouseup",e=>{this.onMouseUpDocument(e)}),g(t,"mouseup",e=>{this.onMouseUp(e)}),g(t,"dblclick",e=>{this.onDoubleClick(e)}),g(t,"mousewheel",e=>{this.onMouseWheel(e)}),g(t,"DOMMouseScroll",e=>{this.onMouseWheel(e)}),g(t,"contextmenu",e=>{this.onContextMenu(e)})),g(window,"resize",e=>{r||(r=setTimeout(()=>{r=null,h.setSize(h.container.offsetWidth,h.container.offsetHeight)},250))})}cancelEvent(e){e.preventDefault&&e.preventDefault(),e.returnValue=!1}onDoubleClick(e){le.speedUp(),this.cancelEvent(e),this.emit("doubleclick",{...m(e),buttons:e.buttons}),this.isDisabled||h.setZoom(h.zoom+1,e)}onMouseDown(e){le.speedUp(),this.cancelEvent(e),this.startZoom=h.zoom,this.prevRotation=h.rotation,this.prevTilt=h.tilt,this.prevX=e.clientX,this.prevY=e.clientY,1===e.buttons&&e.altKey||2===e.buttons?this.buttons=2:1===e.buttons&&(this.buttons=1),this.emit("pointerdown",{...m(e),buttons:e.buttons})}onMouseMoveDocument(e){1===this.buttons?(le.speedUp(),this.moveMap(e)):2===this.buttons&&(le.speedUp(),this.rotateMap(e)),this.prevX=e.clientX,this.prevY=e.clientY}onMouseMove(e){this.emit("pointermove",m(e))}onMouseUpDocument(e){this.buttons&&(1===this.buttons?this.moveMap(e):2===this.buttons&&this.rotateMap(e),this.buttons=0)}onMouseUp(e){const t=m(e);le.Picking.getTargets(t.x,t.y,t=>{this.emit("pointerup",{buttons:e.buttons,targets:t})})}onMouseWheel(e){le.speedUp(),this.cancelEvent(e);let t=0;if(e.wheelDeltaY?t=e.wheelDeltaY:e.wheelDelta?t=e.wheelDelta:e.detail&&(t=-e.detail),!this.isDisabled){const i=.2*(t>0?1:t<0?-1:0);h.setZoom(h.zoom+i,e)}}onContextMenu(e){this.cancelEvent(e)}moveMap(e){if(this.isDisabled)return;const t=.86*Math.pow(2,-h.zoom),i=1/Math.cos(h.position.latitude/180*Math.PI),r=e.clientX-this.prevX,o=e.clientY-this.prevY,n=h.rotation*Math.PI/180,a=[Math.cos(n),Math.sin(n)],s=[Math.cos(n-Math.PI/2),Math.sin(n-Math.PI/2)],u=f(c(a,r),c(s,-o)),l={longitude:h.position.longitude-u[0]*t*i,latitude:h.position.latitude+u[1]*t};h.setPosition(l),this.emit("move",l)}rotateMap(e){this.isDisabled||(this.prevRotation+=(e.clientX-this.prevX)*(360/this.window.innerWidth),this.prevTilt-=(e.clientY-this.prevY)*(360/this.window.innerHeight),h.setRotation(this.prevRotation),h.setTilt(this.prevTilt))}emitGestureChange(e){const t=e.touches[0],i=e.touches[1],r=t.clientX-i.clientX,o=t.clientY-i.clientY,n=r*r+o*o,a=Math.atan2(o,r);this.onGestureChangeDocument({rotation:(a-this.startAngle)*(180/Math.PI)%360,scale:Math.sqrt(n/this.startDist)})}onTouchStart(e){le.speedUp(),this.cancelEvent(e),this.buttons=1;const t=e.touches[0];if(2===e.touches.length&&!("ongesturechange"in this.window)){const i=e.touches[1],r=t.clientX-i.clientX,o=t.clientY-i.clientY;this.startDist=r*r+o*o,this.startAngle=Math.atan2(o,r)}this.startZoom=h.zoom,this.prevRotation=h.rotation,this.prevTilt=h.tilt,this.prevX=t.clientX,this.prevY=t.clientY,this.emit("pointerdown",{x:e.x,y:e.y,buttons:1})}onTouchMoveDocument(e){if(!this.buttons)return;le.speedUp();const t=e.touches[0];e.touches.length>1?(h.setTilt(this.prevTilt+(this.prevY-t.clientY)*(360/this.window.innerHeight)),this.prevTilt=h.tilt,"ongesturechange"in this.window||this.emitGestureChange(e)):this.moveMap(t),this.prevX=t.clientX,this.prevY=t.clientY}onTouchMove(e){1===e.touches.length&&this.emit("pointermove",{...m(e.touches[0]),buttons:1})}onTouchEndDocument(e){if(!this.buttons)return;const t=e.touches[0];if(0===e.touches.length){this.buttons=0;const t=m(e);le.Picking.getTargets(t.x,t.y,e=>{this.emit("pointerup",{buttons:1,targets:e})})}else 1===e.touches.length&&(this.prevX=t.clientX,this.prevY=t.clientY)}onGestureChangeDocument(e){this.buttons&&(le.speedUp(),this.cancelEvent(e),this.isDisabled||(h.setZoom(this.startZoom+(e.scale-1)),h.setRotation(this.prevRotation-e.rotation)),this.emit("gesture",e))}on(e,t){(this.listeners[e]||(this.listeners[e]=[])).push(t)}off(e,t){this.listeners[e]=(this.listeners[e]||[]).filter(e=>e!==t)}emit(e,t){void 0!==this.listeners[e]&&setTimeout(()=>{this.listeners[e].forEach(e=>e(t))},0)}destroy(){this.listeners={}}}const v=14.5,p=22,w=55;var T=256,A=25,b=(e.parse("rgb(220, 210, 200)").toArray(),"#e8e0d8"),E="#efe8e0",M=window.document,y=6378137*Math.PI*2,P=y/360,D=2048,B="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAQMAAACQp+OdAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3wwCCAUQLpaUSQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAGUExURebm5v///zFES9kAAAAcSURBVCjPY/gPBQyUMh4wAAH/KAPCoFaoDnYGAAKtZsamTRFlAAAAAElFTkSuQmCC",S="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4gUHDxACbf+ToAAABKBJREFUeNrt3YFtKjEURFGWBmiE/iuhka0AOgCxWpDte04DP/nxG88zkbJdWMLjdnv+89+77/vmf31+foiGXDgIAAy8QBAAGHiBIAAw9MJAAGDohYEAwNALAwGAwRcEAgCDLwgEAAZfEAgADL4gEAAGH0EgAAw+gkAAGHwEgQAw/AgBAWDwEQQCwPAjBASA4UcICACDjyAQAIYfISAADD9CQAAYfoSAADD4CAIBYPgRAgLA8CMEBIDhRwgIAMOPEBAAhh8hcIqrHzd0ZZLO7Y8WEA0Aw48QiAaA4UcIRAPA8CMEogFg+BECn/kUAMKWTDW3P1pANAAMP0LACgDUGoDbHy0gGgCGHyFgBQBqDcDtjxagAQC1BuD2RwvQAIBaA3D7owVoAECtAbj90QI0AKDWANz+aAEaAFBrAG5/tAANABAAQGYFUP+xBmgAgAAAMiuA+o81QAMABACQWQHUf6wBGgAgAAABAKz/BmD/xzuABgAIAEAAAOu/Adj/8Q6gAQACABAAgAAABAAgAIAjhv14wkeArGTUjwI1ALACAAIAEACAAAAEACAAAAEACABAAAACABAAgAAABAAgAAABAAgAQAAAAgAQAIAAAAQAIAAAAQD8zjbyF+ePg7CCUf8oiAYAVgBAAAACAOjYRv8CPQQys5EfADUAsAIAAgDwBuAdABr7vwYAVgDACmANgFT91wDACgAIAJUKBADQuawEAIRNV6t9GoDbXwMABACQWgGsAaj/GgBQDQC/EwAaALiUBABw1NRV2mMgbn8NACgGgMdA0ADAJSQAgG8tUaE9BuL21wCAYgPQAnD7awBAtQFoAbj9NQCgGgB+MQg0AHDJVANACwANAFwuAgB4Z9m67CNB3P4aAFBsAFoAbn8NAKg2AC0At78GAFQbgBaA218DAKoNQAvA7R8PACGA4bcCANUGoAXg9tcAgGoD0AJw+2sAQLUBaAG4/TUA0ADK37wWQPn21wBAA2jTAtz+5e9fA8DwCwCHAKwAVgEEvwYAaABaAG5/DQDQALQA3P4aABh+AeCQgBXAKoBg1wAADUALwO2vAYDhFwAOD1gBrAIIcA0A0AC0ANz+GgAYfgHgUIEAAEEtABwu+DMH+gAPggJaAwDDLwAcNrACWAUQyBoAGH4B4PCBAAAB7A3AWwCGXwNwGEEAgMAVAA4leAPwHoCg1QDA8AsAhxSsAFYBBKsGAIZfADi0IAAQpHgD8BZg+NEAHGIQAAhOrABWAcOPBuBQgwBAUGIFsAoYfjQAhxwEAIIRK4BVwPCjATj0IAAQhFYArAKGXwPAECAAQPBZAbAKGH4BgBAw/FYADAcCAAScFQCrgOHXADAsCAAQaFYArAKGXwPA8CAAQIBZAciuAoZfABANAcNvBcBQIQAQVFgBSKwChl8DwJAhABBMWAFIrAKGXwAQDQHDbwXA8CEAEEBYAUisAoZfA8BNjABA4GAFILEKGH4BQDQEDL8VAPUcAYBgwQpAYhUw/AKAaAgYfisAajsaALUmIEA0ALQHBACGGSsAiVVAYAgAoiFg+K0AWBUQABhyrAAkVgHBAMEQmPEPj3KeFy7fLVanpR7MAAAAAElFTkSuQmCC";function C(e,t){if(!e)throw t}function F(e,t){var i=[];for(var r in e)i.push([e[r][0],e[r][1],t]);return i}function R(e,t,i){return Math.min(i,Math.max(e,t))}class _{constructor(e,t,i={},r=2){this.source=e,this.tileClass=t,this.tiles={},this.buffer=1,this.queue=[];for(let e=0;e<r;e++)this.queueNext();this.update(),this.fixedZoom=i.fixedZoom,this.bounds=i.bounds||{w:-180,s:-90,e:180,n:90},this.minZoom=Math.max(parseFloat(i.minZoom||h.minZoom),h.minZoom),this.maxZoom=Math.min(parseFloat(i.maxZoom||h.maxZoom),h.maxZoom),this.maxZoom<this.minZoom&&(this.minZoom=h.minZoom,this.maxZoom=h.maxZoom)}getURL(e,t,i){const r="abcd"[(e+t)%4];return o=this.source,n={s:r,x:e,y:t,z:i},o.replace(/\{(\w+)\}/g,function(e,t){return n[t]||e});var o,n}getClosestTiles(e,t){return e}mergeTiles(e,t,i){const r={},o={},n=[];let a;if(0===t||t<=this.minZoom){for(a in e)e[a][2]=t;return e}for(a in e){const s=e[a],u=(s[0]<<0)/2,h=(s[1]<<0)/2;if(void 0===r[[u,h]]){const e=Z(u,h,t-1,le.viewProjMatrix);r[[u,h]]=e<i}r[[u,h]]||void 0===o[[s[0],s[1]]]&&(o[[s[0],s[1]]]=!0,n.push([s[0],s[1],t]))}let s=[];for(a in r)if(r[a]){const e=a.split(",");s.push([parseInt(e[0]),parseInt(e[1]),t-1])}return s.length>0&&(s=this.mergeTiles(s,t-1,i)),n.concat(s)}getDistance(e,t){const i=e[0]-t[0],r=e[1]-t[1];return i*i+r*r}update(){if(h.zoom<this.minZoom||h.zoom>this.maxZoom)return;const e=Math.round(this.fixedZoom||h.zoom);let t=le.getViewQuad(le.viewProjMatrix.data),i=q([h.position.longitude,h.position.latitude],1<<e);for(let i=0;i<4;i++)t[i]=W(t[i],e);let r=function(e){C(4==e.length,"Error: Quadrilateral with more or less than four vertices");var t=H(e[0],e[1],e[2]),i=H(e[0],e[2],e[3]);return t.concat(i)}(t);const o={};(r=this.fixedZoom?this.getClosestTiles(r,i):this.mergeTiles(r,e,.5*T*T)).forEach(t=>{void 0===t[2]&&(t[2]=e),o[t.join(",")]=!0}),this.visibleTiles=o;for(let e in o){const t=e.split(","),i=parseInt(t[0]),r=parseInt(t[1]),o=parseInt(t[2]);this.tiles[e]||(this.tiles[e]=new this.tileClass(i,r,o),this.queue.push(this.tiles[e]))}this.purge(o),this.queue.forEach(e=>{e.distance=this.getDistance([e.x,e.y],i)}),this.queue.sort((e,t)=>t.distance-e.distance),setTimeout(()=>{this.update()},100)}queueNext(){if(!this.queue.length)return void setTimeout(this.queueNext.bind(this),200);const e=this.queue.pop();e.load(this.getURL(e.x,e.y,e.zoom),()=>{this.queueNext()})}purge(e){const t=Math.round(h.zoom);for(let i in this.tiles){let r=this.tiles[i];if(!e[i])if(this.fixedZoom)this.tiles[i].destroy(),delete this.tiles[i];else{if(r.zoom===t+1){if(e[[r.x/2<<0,r.y/2<<0,t].join(",")])continue}r.zoom===t-1&&(e[[2*r.x,2*r.y,t].join(",")]||e[[2*r.x+1,2*r.y,t].join(",")]||e[[2*r.x,2*r.y+1,t].join(",")]||e[[2*r.x+1,2*r.y+1,t].join(",")])||delete this.tiles[i]}}this.queue=this.queue.filter(e=>!!e)}destroy(){for(let e in this.tiles)this.tiles[e].destroy();this.tiles={},this.queue=[]}}class I{constructor(e,t,i){this.x=e,this.y=t,this.zoom=i,this.key=[e,t,i].join(","),this.distance=1/0}load(){}destroy(){}}class L extends I{constructor(e,t,i){super(e,t,i),this.latitude=J(t,i),this.longitude=K(e,i);const o=Y(this.latitude,i),n=[o,o,0,o,0,0,0,o,0,0,0,0];this.vertexBuffer=new r.Buffer(3,new Float32Array(n)),this.texCoordBuffer=new r.Buffer(2,new Float32Array([1,0,1,1,0,0,0,1]))}load(e,t){this.texture=(new r.texture.Image).load(e,e=>{e&&(l.bindTexture(l.TEXTURE_2D,this.texture.id),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_S,l.CLAMP_TO_EDGE),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_WRAP_T,l.CLAMP_TO_EDGE),this.isReady=!0),t&&t()})}destroy(){this.vertexBuffer.destroy(),this.texCoordBuffer.destroy(),this.texture&&this.texture.destroy()}}class N extends I{constructor(e,t,i,r){super(e,t,i),this.options=r}load(e,t){this.content=new G("GeoJSON",e,this.options,t)}destroy(){this.content&&this.content.destroy()}}class U extends o{constructor(...e){super(...e),this.tintCallback=(()=>{}),this.zScaleCallback=(()=>{})}setTintCallback(e){this.tintCallback=e,this.forEach(e=>{e.applyTintAndZScale()})}setZScaleCallback(e){this.zScaleCallback=e,this.forEach(e=>{e.applyTintAndZScale()})}}class G{constructor(e,t,i={},o=function(){}){this.type=e,this.url=t,this.options=i,this.callback=o,this.id=i.id,this.color=i.color,this.matrix=new r.Matrix,this.translate(0,0,i.elevation||0),this.scale(i.scale||1),this.rotate(i.rotation||0),this.minZoom=Math.max(parseFloat(i.minZoom||v),h.minZoom),this.maxZoom=Math.min(parseFloat(i.maxZoom||p),h.maxZoom),this.maxZoom<this.minZoom&&(this.minZoom=v,this.maxZoom=p),this.load()}load(){h.workers.get(e=>{e.onMessage(t=>{if("error"===t)return this.callback(),void e.free();"load"!==t?(this.onLoad(t),e.free()):this.callback()}),e.postMessage({type:this.type,url:this.url,options:this.options})})}onLoad(e){this.position=e.position,this.prevX=0,this.prevY=0,this.vertexBuffer=new r.Buffer(3,e.vertices),this.timer=setTimeout(()=>{this.normalBuffer=new r.Buffer(3,e.normals),this.timer=setTimeout(()=>{this.colorBuffer=new r.Buffer(3,e.colors),this.timer=setTimeout(()=>{this.texCoordBuffer=new r.Buffer(2,e.texCoords),this.timer=setTimeout(()=>{this.heightBuffer=new r.Buffer(1,e.heights),this.timer=setTimeout(()=>{this.pickingBuffer=new r.Buffer(3,e.pickingColors),this.timer=setTimeout(()=>{this.items=e.items,this.applyTintAndZScale(),h.features.add(this),this.fade=0},20)},20)},20)},20)},20)},20)}translate(e=0,t=0,i=0){this.matrix.translate(e,t,i)}scale(e){this.matrix.scale(e,e,e)}rotate(e){this.matrix.rotateZ(-e)}getMatrix(){const e=this.position.longitude-h.position.longitude,t=this.position.latitude-h.position.latitude,i=e-this.prevX,r=t-this.prevY,o=P*Math.cos(h.position.latitude/180*Math.PI);return this.matrix.translate(i*o,-r*P,0),this.prevX=e,this.prevY=t,this.matrix}getFade(){if(this.fade>=1)return 1;le.speedUp();const e=this.fade;return this.fade+=1/60,e}applyTintAndZScale(){const t=[],i=h.features.tintCallback,o=[],n=h.features.zScaleCallback;this.items.forEach(r=>{const a={id:r.id,properties:r.properties},s=i(a),u=s?[...e.parse(s).toArray(),1]:[0,0,0,0],h=n(a);for(let e=0;e<r.vertexCount;e++)t.push(...u),o.push(h?0:1)}),this.tintBuffer=new r.Buffer(4,new Float32Array(t)),this.zScaleBuffer=new r.Buffer(1,new Float32Array(o))}destroy(){h.features.remove(this),clearTimeout(this.timer),this.vertexBuffer&&this.vertexBuffer.destroy(),this.normalBuffer&&this.normalBuffer.destroy(),this.colorBuffer&&this.colorBuffer.destroy(),this.texCoordBuffer&&this.texCoordBuffer.destroy(),this.heightBuffer&&this.heightBuffer.destroy(),this.pickingBuffer&&this.pickingBuffer.destroy(),this.tintBuffer&&this.tintBuffer.destroy(),this.zScaleBuffer&&this.zScaleBuffer.destroy(),this.items=[]}}class O{constructor(){this.size=5e3,this.minZoom=h.minZoom,this.maxZoom=h.maxZoom,this.matrix=new r.Matrix,this.createGeometry()}createGeometry(){const e=2*this.size/50,t=[0,0,1],i=[...t,...t,...t,...t,...t,...t],o=[],n=[],a=[];for(let t=0;t<50;t++)for(let r=0;r<50;r++){const s=-this.size+t*e,u=-this.size+r*e;o.push(s,u,0,s+e,u+e,0,s+e,u,0,s,u,0,s,u+e,0,s+e,u+e,0),n.push(...i),a.push(1,1,1,1,1,1)}this.vertexBuffer=new r.Buffer(3,new Float32Array(o)),this.normalBuffer=new r.Buffer(3,new Float32Array(n)),this.zScaleBuffer=new r.Buffer(1,new Float32Array(a))}getFade(){return 1}getMatrix(){return this.matrix}destroy(){this.vertexBuffer.destroy(),this.normalBuffer.destroy()}}function C(e,t){if(!e)throw t}function z(e,t,i){var r=[e[0]<t[0]?1:-1,e[1]<t[1]?1:-1],o=i[0]+(e[0]<t[0]?1:0),n=i[1]+(e[1]<t[1]?1:0),a=(o-e[0])/(t[0]-e[0]),s=(n-e[1])/(t[1]-e[1]);return(a<=0||a>1)&&(s<=0||s>1)?[void 0,void 0]:a<=0||a>1?[i[0],i[1]+r[1]]:s<=0||s>1?[i[0]+r[0],i[1]]:a<s?[i[0]+r[0],i[1]]:[i[0],i[1]+r[1]]}function H(e,t,i){var r=[e,t,i];if(r.sort(function(e,t){return e[1]<t[1]}),e=r[0],t=r[1],i=r[2],e[1]==t[1])return k(e,t,i);if(t[1]==i[1])return k(t,i,e);var o=(t[1]-e[1])/(i[1]-e[1]),n=[e[0]+o*(i[0]-e[0]),t[1]];return k(n,t,e).concat(k(n,t,i))}function k(e,t,i){var r=[];if(C(e[1]===t[1],"not a flat triangle"),C(i[1]!==e[1],"not a triangle"),C(e[0]!==t[0],"not a triangle"),e[0]>t[0]){var o=e;e=t,t=o}var n=[i[0]<<0,i[1]<<0],a=n.slice(0);r.push(n.slice(0));for(var s,u,h=i[1]<e[1]?1:-1,l=n[1],d=(e[1]<<0)+h,f=l;f*h<d*h;f+=h){do{r.push(n.slice(0)),s=n,n=z(i,e,n)}while(n[1]*h<=f*h);n=s;do{r.push(a.slice(0)),u=a,a=z(i,t,a)}while(a[1]*h<=f*h);a=u;for(var c=n[0];c<=a[0];c++)r.push([c,f])}return r}function V(e,t){var i=t[0]*e[0]+t[1]*e[4]+t[2]*e[8]+e[12],r=t[0]*e[1]+t[1]*e[5]+t[2]*e[9]+e[13],o=t[0]*e[2]+t[1]*e[6]+t[2]*e[10]+e[14],n=t[0]*e[3]+t[1]*e[7]+t[2]*e[11]+e[15];return[i/n,r/n,o/n]}function X(e,t,i){var r=V(i,[e,t,0]),o=oe(V(i,[e,t,1]),r);if(!(o[2]>=0)){var n=ne(r,ae(o,-r[2]/o[2]));return[n[0],n[1]]}}function Z(e,t,i,o){var n=P*Math.cos(h.position.latitude/180*Math.PI),a=K(e,i),s=J(t,i),u=new r.Matrix;u.translate((a-h.position.longitude)*n,-(s-h.position.latitude)*P,0);var l,d=Y(h.position.latitude,i),f=r.Matrix.multiply(u,o),c=V(f,[0,0,0]),m=V(f,[d,0,0]),g=V(f,[0,d,0]),x=V(f,[d,d,0]),v=[c,m,g,x];for(var p in v)v[p][0]=(v[p][0]+1)/2*h.width,v[p][1]=(v[p][1]+1)/2*h.height;return Q((l=[c,m,x,g])[0],l[1],l[2])+Q(l[0],l[2],l[3])}function Q(e,t,i){var r=$(te(e,t)),o=$(te(e,i)),n=$(te(t,i)),a=.5*(r+o+n);return Math.sqrt(a*(a-r)*(a-o)*(a-n))}function Y(e,t){return y*Math.cos(e/180*Math.PI)/Math.pow(2,t)}function j(e){var t=P*Math.cos(h.position.latitude/180*Math.PI);return{longitude:h.position.longitude+e[0]/t,latitude:h.position.latitude-e[1]/P}}function W(e,t){const i=j(e);return q([i.longitude,i.latitude],1<<t)}function q(e,t=1){return[(e[0]/360+.5)*t,(1-Math.log(Math.tan(e[1]*Math.PI/180)+1/Math.cos(e[1]*Math.PI/180))/Math.PI)/2*t]}function K(e,t){return e/Math.pow(2,t)*360-180}function J(e,t){var i=Math.PI-2*Math.PI*e/Math.pow(2,t);return 180/Math.PI*Math.atan(.5*(Math.exp(i)-Math.exp(-i)))}function $(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function ee(e,t){return e[0]*t[0]+e[1]*t[1]}function te(e,t){return[e[0]-t[0],e[1]-t[1]]}function f(e,t){return[e[0]+t[0],e[1]+t[1]]}function c(e,t){return[e[0]*t,e[1]*t]}function ie(e){var t=$(e);return[e[0]/t,e[1]/t]}function re(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function oe(e,t){return[e[0]-t[0],e[1]-t[1],e[2]-t[2]]}function ne(e,t){return[e[0]+t[0],e[1]+t[1],e[2]+t[2]]}function ae(e,t){return[e[0]*t,e[1]*t,e[2]*t]}function se(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}function ue(e){var t=se(e);return[e[0]/t,e[1]/t,e[2]/t]}function he(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}class le{constructor(){this.metersPerDegreeLongitude=P*Math.cos(h.position.latitude/180*Math.PI)}static getViewQuad(){return function(e,t,i){const o=r.Matrix.invert(e);let n,a,s,u,h,l=X(-1,-1,o),d=X(1,-1,o),m=X(1,1,o),g=X(-1,1,o);if(l&&d)return g&&m||(h=ee(n=ie(te(s=X(-1,-.9,o),l)),i),g=f(l,c(n,t/h)),h=ee(a=ie(te(u=X(1,-.9,o),d)),i),m=f(d,c(a,t/h))),ee(i,te(g,l))>t&&(h=ee(n=ie(te(g,l)),i),g=f(l,c(n,t/h))),ee(i,te(m,d))>t&&(h=ee(a=ie(te(m,d)),i),m=f(d,c(a,t/h))),[l,d,m,g]}(this.viewProjMatrix.data,this.fogDistance+this.fogBlurDistance,this.viewDirOnMap)}static start(){le.effects={shadows:!0},this.metersPerDegreeLongitude=P*Math.cos(h.position.latitude/180*Math.PI),l.depthTextureExtension||(console.warn("Shadows are disabled because your GPU does not support WEBGL_depth_texture"),le.effects.shadows=!1),this.setupViewport(),l.cullFace(l.BACK),l.enable(l.CULL_FACE),l.enable(l.DEPTH_TEST),le.Picking=new de,le.Horizon=new ve,le.Buildings=new ce,le.Marker=new we,le.Basemap=new ge,le.Overlay.init(),le.AmbientMap.init(),le.blurredAmbientMap=new pe,le.MapShadows=new me,le.effects.shadows&&(le.cameraGBuffer=new xe,le.sunGBuffer=new xe),this.speedUp(),this.renderFrame()}static renderFrame(){h.zoom>=h.minZoom&&h.zoom<=h.maxZoom&&requestAnimationFrame(()=>{this.setupViewport(),this.metersPerDegreeLongitude=P*Math.cos(h.position.latitude/180*Math.PI),l.clearColor(this.fogColor[0],this.fogColor[1],this.fogColor[2],0),l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT);const e=[h.width,h.height];if(le.effects.shadows){const t=this.getViewQuad();fe.updateView(t),le.Horizon.updateGeometry(t),le.cameraGBuffer.render(this.viewMatrix,this.projMatrix,e,!0),le.sunGBuffer.render(fe.viewMatrix,fe.projMatrix,[D,D]),le.AmbientMap.render(le.cameraGBuffer.framebuffer.depthTexture,le.cameraGBuffer.framebuffer.renderTexture,e,2),le.blurredAmbientMap.render(le.AmbientMap.framebuffer.renderTexture,e),le.Buildings.render(le.sunGBuffer.framebuffer),le.Basemap.render(),l.enable(l.BLEND),l.blendFuncSeparate(l.ZERO,l.SRC_COLOR,l.ZERO,l.ONE),le.MapShadows.render(fe,le.sunGBuffer.framebuffer,.5),le.Overlay.render(le.blurredAmbientMap.framebuffer.renderTexture,e),l.blendFuncSeparate(l.ONE_MINUS_DST_ALPHA,l.DST_ALPHA,l.ONE,l.ONE),l.disable(l.DEPTH_TEST),le.Horizon.render(),l.enable(l.DEPTH_TEST),l.disable(l.BLEND),le.Marker.render()}else le.Buildings.render(),le.MarkerRender.render(),l.enable(l.BLEND),l.blendFuncSeparate(l.ONE_MINUS_DST_ALPHA,l.DST_ALPHA,l.ONE,l.ONE),l.disable(l.DEPTH_TEST),le.Horizon.render(),l.disable(l.BLEND),l.enable(l.DEPTH_TEST),le.Basemap.render();this.isFast?this.renderFrame():setTimeout(()=>{this.renderFrame()},250)})}static setupViewport(){l.canvas.width!==h.width&&(l.canvas.width=h.width),l.canvas.height!==h.height&&(l.canvas.height=h.height);const e=1.3567*Math.pow(2,h.zoom-17),t=h.width,i=h.height;l.viewport(0,0,t,i),this.viewMatrix=(new r.Matrix).rotateZ(h.rotation).rotateX(h.tilt).translate(0,8/e,0).translate(0,0,-1220/e),this.viewDirOnMap=[Math.sin(h.rotation/180*Math.PI),-Math.cos(h.rotation/180*Math.PI)];const o=1024/(2*Math.tan(.125*Math.PI)),n=2*Math.atan(i/2/o)/Math.PI*180;this.nearPlane=1,this.farPlane=3e4,this.projMatrix=(new r.Matrix).translate(0,-i/(2*e),0).scale(1,-1,1).multiply(new r.Matrix.Perspective(n,t/i,this.nearPlane,this.farPlane)).translate(0,-1,0),this.viewProjMatrix=new r.Matrix(r.Matrix.multiply(this.viewMatrix,this.projMatrix)),this.lowerLeftOnMap=X(-1,-1,r.Matrix.invert(this.viewProjMatrix.data)),void 0!==this.lowerLeftOnMap&&(this.fogDistance=5e3,this.fogBlurDistance=1e4)}static speedUp(){this.isFast=!0,clearTimeout(this.speedTimer),this.speedTimer=setTimeout(()=>{this.isFast=!1},1e3)}static destroy(){le.Picking.destroy(),le.Horizon.destroy(),le.Buildings.destroy(),le.Marker.destroy(),le.Basemap.destroy(),le.MapShadows.destroy(),le.cameraGBuffer&&le.cameraGBuffer.destroy(),le.sunGBuffer&&le.sunGBuffer.destroy(),le.AmbientMap.destroy(),le.blurredAmbientMap.destroy(),clearTimeout(this.speedTimer)}}class de{constructor(){this.size=[512,512],this.shader=new r.Shader({vertexShader:i.picking.vertex,fragmentShader:i.picking.fragment,shaderName:"picking shader",attributes:["aPosition","aPickingColor","aZScale"],uniforms:["uModelMatrix","uMatrix","uFogDistance","uFade","uIndex"]}),this.framebuffer=new r.Framebuffer(this.size[0],this.size[1])}getTargets(e,t,i){requestAnimationFrame(()=>{const o=this.shader;o.enable(),this.framebuffer.enable(),l.viewport(0,0,this.size[0],this.size[1]),l.clearColor(0,0,0,1),l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT),o.setParam("uFogDistance","1f",le.fogDistance);const n=[];h.features.forEach(e=>{if(h.zoom<e.minZoom||h.zoom>e.maxZoom)return;let t=e.getMatrix();t&&(n.push(e.items),o.setParam("uFade","1f",e.getFade()),o.setParam("uIndex","1f",n.length/256),o.setMatrix("uModelMatrix","4fv",t.data),o.setMatrix("uMatrix","4fv",r.Matrix.multiply(t,le.viewProjMatrix)),o.setBuffer("aPosition",e.vertexBuffer),o.setBuffer("aPickingColor",e.pickingBuffer),o.setBuffer("aZScale",e.zScaleBuffer),l.drawArrays(l.TRIANGLES,0,e.vertexBuffer.numItems))}),o.disable(),l.viewport(0,0,h.width,h.height);const a=e/h.width*this.size[0]<<0,s=t/h.height*this.size[1]<<0,u=this.framebuffer.getPixel(a,this.size[1]-1-s);if(this.framebuffer.disable(),!u)return void i();const d=u[0]-1,f=(u[1]|u[2]<<8)-1;if(!n[d]||!n[d][f])return void i();const c=n[d][f],m={id:c.id,properties:c.properties,parts:[]},g=c.properties.building||c.id;h.features.forEach(e=>{e.items.forEach(e=>{e.id!==g&&e.properties.building!==g||m.parts.push({id:e.id,properties:e.properties})})}),i(m)})}destroy(){this.shader.destroy(),this.framebuffer.destroy()}}var fe={setDate:function(e){var i=t(e,h.position.latitude,h.position.longitude);this.direction=[-Math.sin(i.azimuth)*Math.cos(i.altitude),Math.cos(i.azimuth)*Math.cos(i.altitude),Math.sin(i.altitude)];var o=i.azimuth/(Math.PI/180),n=90-i.altitude/(Math.PI/180);this.viewMatrix=(new r.Matrix).rotateZ(o).rotateX(n).translate(0,0,-5e3).scale(1,-1,1)},updateView:function(e){this.projMatrix=function(e,t,i,o,n){for(var a=V(t.data,e[0]),s=a[0],u=a[0],h=a[1],l=a[1],d=0;d<e.length;d++){var f=V(t.data,e[d]);s=Math.min(s,f[0]),u=Math.max(u,f[0]),h=Math.max(h,f[1]),l=Math.min(l,f[1])}return new r.Matrix.Ortho(s,u,h,l,i,o)}(F(e,0).concat(F(e,100)),this.viewMatrix,1e3,7500),this.viewProjMatrix=new r.Matrix(r.Matrix.multiply(this.viewMatrix,this.projMatrix))}};class ce{constructor(){this.shader=le.effects.shadows?new r.Shader({vertexShader:i.buildings_with_shadows.vertex,fragmentShader:i.buildings_with_shadows.fragment,shaderName:"quality building shader",attributes:["aPosition","aTexCoord","aColor","aNormal","aHeight","aTintColor","aZScale"],uniforms:["uFogDistance","uFogBlurDistance","uLightColor","uLightDirection","uLowerEdgePoint","uMatrix","uModelMatrix","uSunMatrix","uShadowTexIndex","uShadowTexDimensions","uFade","uViewDirOnMap","uWallTexIndex"]}):new r.Shader({vertexShader:i.buildings.vertex,fragmentShader:i.buildings.fragment,shaderName:"building shader",attributes:["aPosition","aTexCoord","aColor","aNormal","aHeight","aTintColor","aZScale"],uniforms:["uModelMatrix","uViewDirOnMap","uMatrix","uNormalTransform","uLightColor","uLightDirection","uLowerEdgePoint","uFogDistance","uFogBlurDistance","uFade","uWallTexIndex"]}),this.wallTexture=new r.texture.Image,this.wallTexture.color([1,1,1]),this.wallTexture.load(B)}render(e){const t=this.shader;t.enable(),t.setParam("uFogDistance","1f",le.fogDistance),t.setParam("uFogBlurDistance","1f",le.fogBlurDistance),t.setParam("uLightColor","3fv",[.5,.5,.5]),t.setParam("uLightDirection","3fv",fe.direction),t.setParam("uLowerEdgePoint","2fv",le.lowerLeftOnMap),t.setParam("uViewDirOnMap","2fv",le.viewDirOnMap),le.effects.shadows||t.setMatrix("uNormalTransform","3fv",r.Matrix.identity3().data),t.setTexture("uWallTexIndex",0,this.wallTexture),e&&(t.setParam("uShadowTexDimensions","2fv",[e.width,e.height]),t.setTexture("uShadowTexIndex",1,e.depthTexture)),h.features.forEach(e=>{if(h.zoom<e.minZoom||h.zoom>e.maxZoom)return;const i=e.getMatrix();i&&(t.setParam("uFade","1f",e.getFade()),t.setMatrix("uModelMatrix","4fv",i.data),t.setMatrix("uMatrix","4fv",r.Matrix.multiply(i,le.viewProjMatrix)),le.effects.shadows&&t.setMatrix("uSunMatrix","4fv",r.Matrix.multiply(i,fe.viewProjMatrix)),t.setBuffer("aPosition",e.vertexBuffer),t.setBuffer("aTexCoord",e.texCoordBuffer),t.setBuffer("aNormal",e.normalBuffer),t.setBuffer("aColor",e.colorBuffer),t.setBuffer("aHeight",e.heightBuffer),t.setBuffer("aTintColor",e.tintBuffer),t.setBuffer("aZScale",e.zScaleBuffer),l.drawArrays(l.TRIANGLES,0,e.vertexBuffer.numItems))}),t.disable()}destroy(){}}class me{constructor(){this.shader=new r.Shader({vertexShader:i.basemap_with_shadows.vertex,fragmentShader:i.basemap_with_shadows.fragment,shaderName:"map shadows shader",attributes:["aPosition","aNormal"],uniforms:["uModelMatrix","uViewDirOnMap","uMatrix","uDirToSun","uLowerEdgePoint","uFogDistance","uFogBlurDistance","uShadowTexDimensions","uShadowStrength","uShadowTexIndex","uSunMatrix"]}),this.mapPlane=new O}render(e,t,i){const o=this.mapPlane;if(h.zoom<o.minZoom||h.zoom>o.maxZoom)return;const n=this.shader;let a;n.enable(),l.disable(l.CULL_FACE),n.setParam("uDirToSun","3fv",e.direction),n.setParam("uViewDirOnMap","2fv",le.viewDirOnMap),n.setParam("uLowerEdgePoint","2fv",le.lowerLeftOnMap),n.setParam("uFogDistance","1f",le.fogDistance),n.setParam("uFogBlurDistance","1f",le.fogBlurDistance),n.setParam("uShadowTexDimensions","2fv",[t.width,t.height]),n.setParam("uShadowStrength","1f",i),n.setTexture("uShadowTexIndex",0,t.depthTexture),(a=o.getMatrix())&&(n.setMatrix("uModelMatrix","4fv",a.data),n.setMatrix("uMatrix","4fv",r.Matrix.multiply(a,le.viewProjMatrix)),n.setMatrix("uSunMatrix","4fv",r.Matrix.multiply(a,e.viewProjMatrix)),n.setBuffer("aPosition",o.vertexBuffer),n.setBuffer("aNormal",o.normalBuffer),l.drawArrays(l.TRIANGLES,0,o.vertexBuffer.numItems),n.disable())}destroy(){this.mapPlane.destroy()}}class ge{constructor(){this.shader=new r.Shader({vertexShader:i.basemap.vertex,fragmentShader:i.basemap.fragment,shaderName:"basemap shader",attributes:["aPosition","aTexCoord"],uniforms:["uViewMatrix","uModelMatrix","uTexIndex","uFogDistance","uFogBlurDistance","uLowerEdgePoint","uViewDirOnMap"]})}render(){const e=h.basemapGrid;if(!e)return;if(h.zoom<e.minZoom||h.zoom>e.maxZoom)return;const t=this.shader;t.enable(),t.setParam("uFogDistance","1f",le.fogDistance),t.setParam("uFogBlurDistance","1f",le.fogBlurDistance),t.setParam("uLowerEdgePoint","2fv",le.lowerLeftOnMap),t.setParam("uViewDirOnMap","2fv",le.viewDirOnMap);const i=Math.round(h.zoom);let r;for(let t in e.visibleTiles){if((r=e.tiles[t])&&r.isReady){this.renderTile(r);continue}const o=[r.x/2<<0,r.y/2<<0,i-1].join(",");if(e.tiles[o]&&e.tiles[o].isReady){this.renderTile(e.tiles[o]);continue}const n=[[2*r.x,2*r.y,r.zoom+1].join(","),[2*r.x+1,2*r.y,r.zoom+1].join(","),[2*r.x,2*r.y+1,r.zoom+1].join(","),[2*r.x+1,2*r.y+1,r.zoom+1].join(",")];for(let t=0;t<4;t++)e.tiles[n[t]]&&e.tiles[n[t]].isReady&&this.renderTile(e.tiles[n[t]])}t.disable()}renderTile(e){const t=this.shader,i=P*Math.cos(h.position.latitude/180*Math.PI),o=new r.Matrix;o.translate((e.longitude-h.position.longitude)*i,-(e.latitude-h.position.latitude)*P,0),l.enable(l.POLYGON_OFFSET_FILL),l.polygonOffset(A-e.zoom,A-e.zoom),t.setMatrix("uModelMatrix","4fv",o.data),t.setMatrix("uViewMatrix","4fv",r.Matrix.multiply(o,le.viewProjMatrix)),t.setBuffer("aPosition",e.vertexBuffer),t.setBuffer("aTexCoord",e.texCoordBuffer),t.setTexture("uTexIndex",0,e.texture),l.drawArrays(l.TRIANGLE_STRIP,0,e.vertexBuffer.numItems),l.disable(l.POLYGON_OFFSET_FILL)}destroy(){}}le.HudRect={init:function(){var e=this.createGeometry();this.vertexBuffer=new r.Buffer(3,new Float32Array(e.vertices)),this.texCoordBuffer=new r.Buffer(2,new Float32Array(e.texCoords)),this.shader=new r.Shader({vertexShader:i.texture.vertex,fragmentShader:i.texture.fragment,shaderName:"HUD rectangle shader",attributes:["aPosition","aTexCoord"],uniforms:["uMatrix","uTexIndex"]})},createGeometry:function(){var e=[],t=[];return e.push(0,0,1e-5,1,0,1e-5,1,1,1e-5),e.push(0,0,1e-5,1,1,1e-5,0,1,1e-5),t.push(.5,.5,1,.5,1,1),t.push(.5,.5,1,1,.5,1),{vertices:e,texCoords:t}},render:function(e){var t=this.shader;t.enable(),l.uniformMatrix4fv(t.uniforms.uMatrix,!1,r.Matrix.identity().data),this.vertexBuffer.enable(),l.vertexAttribPointer(t.attributes.aPosition,this.vertexBuffer.itemSize,l.FLOAT,!1,0,0),this.texCoordBuffer.enable(),l.vertexAttribPointer(t.attributes.aTexCoord,this.texCoordBuffer.itemSize,l.FLOAT,!1,0,0),e.enable(0),l.uniform1i(t.uniforms.uTexIndex,0),l.drawArrays(l.TRIANGLES,0,this.vertexBuffer.numItems),t.disable()},destroy:function(){}};class xe{constructor(){this.shader=new r.Shader({vertexShader:i.depth_normal.vertex,fragmentShader:i.depth_normal.fragment,shaderName:"depth/normal shader",attributes:["aPosition","aNormal","aZScale"],uniforms:["uMatrix","uModelMatrix","uNormalMatrix","uFade","uFogDistance","uFogBlurDistance","uViewDirOnMap","uLowerEdgePoint"]}),this.framebuffer=new r.Framebuffer(128,128,!0),this.mapPlane=new O}render(e,t,i){const o=this.shader,n=this.framebuffer,a=new r.Matrix(r.Matrix.multiply(e,t));n.setSize(i[0],i[1]),o.enable(),n.enable(),l.viewport(0,0,i[0],i[1]),l.clearColor(0,0,0,1),l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT),o.setParam("uViewDirOnMap","2fv",le.viewDirOnMap),o.setParam("uLowerEdgePoint","2fv",le.lowerLeftOnMap),o.setParam("uFogDistance","1f",le.fogDistance),o.setParam("uFogBlurDistance","1f",le.fogBlurDistance),h.features.items.concat([this.mapPlane]).forEach(t=>{if(h.zoom<t.minZoom||h.zoom>t.maxZoom)return;const i=t.getMatrix();i&&(o.setParam("uFade","1f",t.getFade()),o.setMatrix("uMatrix","4fv",r.Matrix.multiply(i,a)),o.setMatrix("uModelMatrix","4fv",i.data),o.setMatrix("uNormalMatrix","3fv",r.Matrix.transpose3(r.Matrix.invert3(r.Matrix.multiply(i,e)))),o.setBuffer("aPosition",t.vertexBuffer),o.setBuffer("aNormal",t.normalBuffer),o.setBuffer("aZScale",t.zScaleBuffer),l.drawArrays(l.TRIANGLES,0,t.vertexBuffer.numItems))}),o.disable(),n.disable(),l.viewport(0,0,h.width,h.height)}destroy(){this.shader.destroy(),this.framebuffer.destroy(),this.mapPlane.destroy()}}le.AmbientMap={init:function(){this.shader=new r.Shader({vertexShader:i.ambient_from_depth.vertex,fragmentShader:i.ambient_from_depth.fragment,shaderName:"SSAO shader",attributes:["aPosition","aTexCoord"],uniforms:["uInverseTexSize","uNearPlane","uFarPlane","uDepthTexIndex","uFogTexIndex","uEffectStrength"]}),this.framebuffer=new r.Framebuffer(128,128),this.vertexBuffer=new r.Buffer(3,new Float32Array([-1,-1,1e-5,1,-1,1e-5,1,1,1e-5,-1,-1,1e-5,1,1,1e-5,-1,1,1e-5])),this.texCoordBuffer=new r.Buffer(2,new Float32Array([0,0,1,0,1,1,0,0,1,1,0,1]))},render:function(e,t,i,r){var o=this.shader,n=this.framebuffer;void 0===r&&(r=1),n.setSize(i[0],i[1]),l.viewport(0,0,i[0],i[1]),o.enable(),n.enable(),l.clearColor(1,0,0,1),l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT),o.setParam("uInverseTexSize","2fv",[1/i[0],1/i[1]]),o.setParam("uEffectStrength","1f",r),o.setParam("uNearPlane","1f",le.nearPlane),o.setParam("uFarPlane","1f",le.farPlane),o.setBuffer("aPosition",this.vertexBuffer),o.setBuffer("aTexCoord",this.texCoordBuffer),o.setTexture("uDepthTexIndex",0,e),o.setTexture("uFogTexIndex",1,t),l.drawArrays(l.TRIANGLES,0,this.vertexBuffer.numItems),o.disable(),n.disable(),l.viewport(0,0,h.width,h.height)},destroy:function(){}},le.Overlay={init:function(){const e=this.createGeometry();this.vertexBuffer=new r.Buffer(3,new Float32Array(e.vertices)),this.texCoordBuffer=new r.Buffer(2,new Float32Array(e.texCoords)),this.shader=new r.Shader({vertexShader:i.texture.vertex,fragmentShader:i.texture.fragment,shaderName:"overlay texture shader",attributes:["aPosition","aTexCoord"],uniforms:["uMatrix","uTexIndex"]})},createGeometry:function(){const e=[],t=[];return e.push(-1,-1,1e-5,1,-1,1e-5,1,1,1e-5),e.push(-1,-1,1e-5,1,1,1e-5,-1,1,1e-5),t.push(0,0,1,0,1,1),t.push(0,0,1,1,0,1),{vertices:e,texCoords:t}},render:function(e,t){const i=this.shader;i.enable(),l.disable(l.DEPTH_TEST),i.setMatrix("uMatrix","4fv",r.Matrix.identity().data),i.setBuffer("aPosition",this.vertexBuffer),i.setBuffer("aTexCoord",this.texCoordBuffer),i.setTexture("uTexIndex",0,e),l.drawArrays(l.TRIANGLES,0,this.vertexBuffer.numItems),l.enable(l.DEPTH_TEST),i.disable()},destroy:function(){}};class ve{constructor(){this.HORIZON_HEIGHT=2e3,this.skyShader=new r.Shader({vertexShader:i.horizon.vertex,fragmentShader:i.horizon.fragment,shaderName:"sky wall shader",attributes:["aPosition"],uniforms:["uAbsoluteHeight","uMatrix","uFogColor"]}),this.v1=this.v2=this.v3=this.v4=[!1,!1,!1],this.updateGeometry([[0,0,0],[0,0,0],[0,0,0],[0,0,0]]),this.floorShader=new r.Shader({vertexShader:i.flat_color.vertex,fragmentShader:i.flat_color.fragment,attributes:["aPosition"],uniforms:["uColor","uMatrix"]})}updateGeometry(e){let t=[e[3][0],e[3][1],0],i=[e[2][0],e[2][1],0],o=[e[2][0],e[2][1],this.HORIZON_HEIGHT],n=[e[3][0],e[3][1],this.HORIZON_HEIGHT];if(he(t,this.v1)&&he(i,this.v2)&&he(o,this.v3)&&he(n,this.v4))return;this.v1=t,this.v2=i,this.v3=o,this.v4=n,this.skyVertexBuffer&&this.skyVertexBuffer.destroy();const a=[...t,...i,...o,...t,...o,...n];this.skyVertexBuffer=new r.Buffer(3,new Float32Array(a)),t=[e[0][0],e[0][1],1],i=[e[1][0],e[1][1],1],o=[e[2][0],e[2][1],1],n=[e[3][0],e[3][1],1],this.floorVertexBuffer&&this.floorVertexBuffer.destroy(),this.floorVertexBuffer=new r.Buffer(3,new Float32Array([...t,...i,...o,...n]))}render(){const e=this.skyShader,t=this.floorShader,i=le.fogColor;e.enable(),e.setParam("uFogColor","3fv",i),e.setParam("uAbsoluteHeight","1f",10*this.HORIZON_HEIGHT),e.setMatrix("uMatrix","4fv",le.viewProjMatrix.data),e.setBuffer("aPosition",this.skyVertexBuffer),l.drawArrays(l.TRIANGLES,0,this.skyVertexBuffer.numItems),e.disable(),t.enable(),t.setParam("uColor","4fv",[...i,1]),t.setMatrix("uMatrix","4fv",le.viewProjMatrix.data),t.setBuffer("aPosition",this.floorVertexBuffer),l.drawArrays(l.TRIANGLE_FAN,0,this.floorVertexBuffer.numItems),t.disable()}destroy(){this.skyVertexBuffer.destroy(),this.skyShader.destroy(),this.floorVertexBuffer.destroy(),this.floorShader.destroy()}}class pe{constructor(){this.shader=new r.Shader({vertexShader:i.blur.vertex,fragmentShader:i.blur.fragment,shaderName:"blur shader",attributes:["aPosition","aTexCoord"],uniforms:["uInverseTexSize","uTexIndex"]}),this.framebuffer=new r.Framebuffer(128,128),this.vertexBuffer=new r.Buffer(3,new Float32Array([-1,-1,1e-5,1,-1,1e-5,1,1,1e-5,-1,-1,1e-5,1,1,1e-5,-1,1,1e-5])),this.texCoordBuffer=new r.Buffer(2,new Float32Array([0,0,1,0,1,1,0,0,1,1,0,1]))}render(e,t){this.framebuffer.setSize(t[0],t[1]),l.viewport(0,0,t[0],t[1]),this.shader.enable(),this.framebuffer.enable(),l.clearColor(1,0,0,1),l.clear(l.COLOR_BUFFER_BIT|l.DEPTH_BUFFER_BIT),this.shader.setParam("uInverseTexSize","2fv",[1/this.framebuffer.width,1/this.framebuffer.height]),this.shader.setBuffer("aPosition",this.vertexBuffer),this.shader.setBuffer("aTexCoord",this.texCoordBuffer),this.shader.setTexture("uTexIndex",0,e),l.drawArrays(l.TRIANGLES,0,this.vertexBuffer.numItems),this.shader.disable(),this.framebuffer.disable(),l.viewport(0,0,h.width,h.height)}destroy(){this.shader.destroy(),this.framebuffer.destroy(),this.vertexBuffer.destroy(),this.texCoordBuffer.destroy()}}class we{constructor(){this.shader=new r.Shader({vertexShader:i.marker.vertex,fragmentShader:i.marker.fragment,shaderName:"marker shader",attributes:["aPosition","aTexCoord"],uniforms:["uProjMatrix","uViewMatrix","uModelMatrix","uTexIndex","markerSize"]})}render(){const e=this.shader;e.enable();const t=le.metersPerDegreeLongitude;l.disable(l.DEPTH_TEST),l.enable(l.BLEND),l.blendFunc(l.SRC_ALPHA,l.ONE_MINUS_SRC_ALPHA),h.markers.forEach(i=>{if(!i.isReady)return;const o=new r.Matrix;o.translate((i.position.longitude-h.position.longitude)*t,-(i.position.latitude-h.position.latitude)*P,i.elevation),e.setParam("markerSize","1f",i.size),e.setMatrix("uProjMatrix","4fv",le.projMatrix.data),e.setMatrix("uViewMatrix","4fv",le.viewMatrix.data),e.setMatrix("uModelMatrix","4fv",o.data),e.setBuffer("aPosition",i.vertexBuffer),e.setBuffer("aTexCoord",i.texCoordBuffer),e.setTexture("uTexIndex",0,i.texture),l.drawArrays(l.TRIANGLES,0,i.vertexBuffer.numItems)}),l.disable(l.BLEND),l.enable(l.DEPTH_TEST),e.disable()}destroy(){this.shader.destroy()}}}();